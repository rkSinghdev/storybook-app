(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.jora = factory());
}(this, (function () { 'use strict';

	var version = "1.0.0-beta.5";
	var _package = {
		version: version
	};

	var _package$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		version: version,
		'default': _package
	});

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var parse = createCommonjsModule(function (module, exports) {
	/* parser generated by jison 0.4.18-remastered.1 */
	module.exports = (function(){
	var o=function(keys, v, o = {}) {
	            keys.forEach(key => o[key] = v);
	            return o;
	        },$V0=[2,5],$V1=[1,13],$V2=[1,41],$V3=[1,18],$V4=[1,7],$V5=[1,8],$V6=[1,10],$V7=[1,11],$V8=[1,12],$V9=[1,19],$V10=[1,20],$V11=[1,21],$V12=[1,22],$V13=[1,23],$V14=[1,24],$V15=[1,25],$V16=[1,29],$V17=[1,32],$V18=[1,33],$V19=[1,34],$V20=[1,35],$V21=[1,36],$V22=[1,37],$V23=[1,42],$V24=[1,43],$V25=[1,40],$V26=[5,18,56,59],$V27=[1,47],$V28=[1,55],$V29=[1,54],$V30=[1,48],$V31=[1,49],$V32=[1,50],$V33=[1,51],$V34=[1,52],$V35=[1,53],$V36=[1,56],$V37=[1,57],$V38=[1,58],$V39=[1,59],$V40=[1,60],$V41=[1,61],$V42=[1,62],$V43=[1,63],$V44=[1,64],$V45=[1,65],$V46=[1,66],$V47=[5,9,14,15,17,18,19,22,23,24,44,45,46,47,48,49,50,54,56,58,59,60,61,62,63,64,72,73,76,77,80],$V48=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V49=[1,67],$V50=[1,68],$V51=[1,69],$V52=[1,70],$V53=[1,71],$V54=[1,72],$V55=[1,73],$V56=[1,76],$V57=[5,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,59,60,61,62,63,64,66,74,75,77,84],$V58=[2,46],$V59=[1,82],$V60=[1,83],$V61=[2,48],$V62=[1,84],$V63=[1,86],$V64=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,59,60,61,62,63,64,66,74,75,77,84],$V65=[5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,54,56,58,59,60,61,62,63,64,66,74,75,77,84],$V66=[1,93],$V67=[1,94],$V68=[1,95],$V69=[1,111],$V70=[1,110],$V71=[1,116],$V72=[1,119],$V73=[1,120],$V74=[1,121],$V75=[1,122],$V76=[1,123],$V77=[9,14,15,17,19,22,23,24,44,45,46,47,48,49,50,54,58,60,61,62,63,64,72,73,74,75,76],$V78=[5,10,11,18,21,56,59,66,74,75,77],$V79=[5,10,11,18,21,29,30,41,56,59,66,74,75,77],$V80=[5,10,11,18,21,23,24,25,26,27,28,29,30,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V81=[56,66],$V82=[2,115],$V83=[11,56],$V84=[66,77],$V85=[2,102],$V86=[2,103],$V87=[5,10,11,18,21,25,26,27,28,29,30,41,56,59,66,74,75,77],$V88=[5,10,11,18,21,25,26,27,28,29,30,34,35,40,41,56,59,66,74,75,77],$V89=[5,10,11,18,21,25,26,27,28,29,30,34,35,36,37,38,39,40,41,56,59,66,74,75,77],$V90=[1,199],$V91=[1,201],$V92=[59,66],$V93=[1,211],$V94=[2,109];
	const parserPrototype = {trace: function(...args) {
	        if (this.DEBUG) {
	            Jison.print(...args);
	        }
	    },
	yy: {},
	symbols_: {"error":2,"root":3,"block":4,"EOF":5,"definitions":6,"e":7,"def":8,"$":9,";":10,":":11,"$ident":12,"ident":13,"IDENT":14,"$IDENT":15,"query":16,"FUNCTION_START":17,"FUNCTION_END":18,"FUNCTION":19,"sortingCompareList":20,"|":21,"NOT":22,"-":23,"+":24,"IN":25,"HAS":26,"NOTIN":27,"HASNO":28,"AND":29,"OR":30,"*":31,"/":32,"%":33,"=":34,"!=":35,"<":36,"<=":37,">":38,">=":39,"~=":40,"?":41,"queryRoot":42,"relativePath":43,"@":44,"#":45,"$$":46,"STRING":47,"NUMBER":48,"REGEXP":49,"LITERAL":50,"template":51,"object":52,"array":53,"[":54,"sliceNotation":55,"]":56,"method()":57,"(":58,")":59,".":60,".(":61,".[":62,"..":63,"..(":64,"arguments":65,",":66,"templateString":67,"templateStart":68,"templateTail":69,"templateEnd":70,"templateContinue":71,"TEMPLATE":72,"TPL_START":73,"TPL_CONTINUE":74,"TPL_END":75,"{":76,"}":77,"properties":78,"property":79,"...":80,"arrayElements":81,"arrayElement":82,"sortingCompare":83,"ORDER":84,"sliceNotationComponent":85,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",9:"$",10:";",11:":",14:"IDENT",15:"$IDENT",17:"FUNCTION_START",18:"FUNCTION_END",19:"FUNCTION",21:"|",22:"NOT",23:"-",24:"+",25:"IN",26:"HAS",27:"NOTIN",28:"HASNO",29:"AND",30:"OR",31:"*",32:"/",33:"%",34:"=",35:"!=",36:"<",37:"<=",38:">",39:">=",40:"~=",41:"?",44:"@",45:"#",46:"$$",47:"STRING",48:"NUMBER",49:"REGEXP",50:"LITERAL",54:"[",56:"]",58:"(",59:")",60:".",61:".(",62:".[",63:"..",64:"..(",66:",",72:"TEMPLATE",73:"TPL_START",74:"TPL_CONTINUE",75:"TPL_END",76:"{",77:"}",80:"...",84:"ORDER"},
	productions_: [0,[3,2],[4,2],[4,1],[4,1],[4,0],[6,1],[6,2],[8,2],[8,4],[8,2],[8,4],[13,1],[12,1],[7,1],[7,3],[7,2],[7,1],[7,3],[7,4],[7,2],[7,2],[7,2],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,5],[16,1],[16,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,1],[42,3],[42,1],[42,1],[42,3],[42,4],[42,2],[42,2],[42,3],[42,3],[42,2],[42,2],[42,3],[43,3],[43,4],[43,4],[43,3],[43,3],[43,4],[43,4],[43,3],[43,3],[43,4],[57,3],[57,4],[57,3],[57,4],[65,1],[65,3],[51,1],[51,2],[69,1],[69,2],[69,2],[69,3],[67,1],[68,1],[71,1],[70,1],[52,2],[52,3],[52,4],[52,3],[52,4],[52,5],[78,1],[78,3],[79,1],[79,1],[79,1],[79,3],[79,3],[79,3],[79,3],[79,3],[79,5],[79,1],[79,2],[81,1],[81,3],[82,1],[82,1],[82,2],[53,2],[53,3],[53,4],[20,1],[20,3],[83,2],[55,1],[55,2],[55,2],[55,3],[85,1],[85,2]],
	performAction: function(yytext,yyleng,yylineno,yy,yystate /* action[1] */,$$ /* vstack */,_$ /* lstack */) {
	/* this == yyval */

	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	return yy.buildResult($$[$0-1])
	case 2:
	this.$ = {type:"Block",definitions:$$[$0-1],body:$$[$0],range:this._$.range};
	break;
	case 3:
	this.$ = {type:"Block",definitions:$$[$0],body:null,range:this._$.range};
	break;
	case 4:
	this.$ = {type:"Block",definitions:[],body:$$[$0],range:this._$.range};
	break;
	case 5:
	this.$ = {type:"Block",definitions:[],body:null,range:this._$.range};
	break;
	case 6: case 82: case 84: case 100: case 113: case 121:
	this.$ = [$$[$0]];
	break;
	case 7:
	$$[$0-1].push($$[$0]);
	break;
	case 8:
	this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-1].range},value:null,range:this._$.range};
	break;
	case 9:
	this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range};
	break;
	case 10:
	this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-1].name,range:_$[$0-1].range},value:null,range:this._$.range};
	break;
	case 11:
	this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-3].name,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range};
	break;
	case 12: case 13:
	this.$ = {type:"Identifier",name:$$[$0],range:this._$.range};
	break;
	case 14: case 42: case 43: case 54: case 55: case 115:

	break;
	case 15:
	this.$ = {type:"Function",arguments:[],body:$$[$0-1],legacy:true,range:this._$.range};
	break;
	case 16:
	this.$ = {type:"Function",arguments:[],body:$$[$0],legacy:false,range:this._$.range};
	break;
	case 17:
	this.$ = {type:"SortingFunction",compares:$$[$0],range:this._$.range};
	break;
	case 18:
	this.$ = {type:"Pipeline",left:$$[$0-2],right:$$[$0],range:this._$.range};
	break;
	case 19:
	this.$ = {type:"Pipeline",left:$$[$0-3],right:{type:"Block",definitions:$$[$0-1],body:$$[$0]},range:this._$.range};
	break;
	case 20: case 21: case 22:
	this.$ = {type:"Unary",operator:$$[$0-1],argument:$$[$0],range:this._$.range};
	break;
	case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40:
	this.$ = {type:"Binary",operator:$$[$0-1],left:$$[$0-2],right:$$[$0],range:this._$.range};
	break;
	case 41:
	this.$ = {type:"Conditional",test:$$[$0-4],consequent:$$[$0-2],alternate:$$[$0],range:this._$.range};
	break;
	case 44:
	this.$ = {type:"Data",range:this._$.range};
	break;
	case 45:
	this.$ = {type:"Context",range:this._$.range};
	break;
	case 46:
	this.$ = {type:"Current",range:this._$.range};
	break;
	case 47:
	this.$ = {type:"Arg1",range:this._$.range};
	break;
	case 48:
	this.$ = {type:"Reference",name:$$[$0],range:this._$.range};
	break;
	case 49: case 50: case 51: case 52: case 90: case 91: case 92: case 93:
	this.$ = {type:"Literal",value:$$[$0],range:this._$.range};
	break;
	case 53:
	this.$ = {type:"Template",values:$$[$0],range:this._$.range};
	break;
	case 56:
	this.$ = {type:"SliceNotation",value:null,arguments:$$[$0-1],range:this._$.range};
	break;
	case 57: case 61:
	this.$ = {type:"GetProperty",value:null,property:$$[$0],range:this._$.range};
	break;
	case 58: case 62:
	this.$ = {type:"MethodCall",value:null,method:$$[$0],range:this._$.range};
	break;
	case 59:
	this.$ = {type:"Parentheses",body:$$[$0-1],range:this._$.range};
	break;
	case 60:
	this.$ = {type:"Parentheses",body:{type:"Block",definitions:$$[$0-2],body:$$[$0-1]},range:this._$.range};
	break;
	case 63:
	this.$ = {type:"Map",value:null,query:$$[$0-1],range:this._$.range};
	break;
	case 64:
	this.$ = {type:"Filter",value:null,query:$$[$0-1],range:this._$.range};
	break;
	case 65:
	this.$ = {type:"MapRecursive",value:null,query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range};
	break;
	case 66:
	this.$ = {type:"MapRecursive",value:null,query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range};
	break;
	case 67:
	this.$ = {type:"MapRecursive",value:null,query:$$[$0-1],range:this._$.range};
	break;
	case 68:
	this.$ = {type:"Pick",value:$$[$0-2],getter:null,range:this._$.range};
	break;
	case 69:
	this.$ = {type:"Pick",value:$$[$0-3],getter:$$[$0-1],range:this._$.range};
	break;
	case 70:
	this.$ = {type:"SliceNotation",value:$$[$0-3],arguments:$$[$0-1],range:this._$.range};
	break;
	case 71:
	this.$ = {type:"GetProperty",value:$$[$0-2],property:$$[$0],range:this._$.range};
	break;
	case 72:
	this.$ = {type:"MethodCall",value:$$[$0-2],method:$$[$0],range:this._$.range};
	break;
	case 73:
	this.$ = {type:"Map",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
	break;
	case 74:
	this.$ = {type:"Filter",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
	break;
	case 75:
	this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range};
	break;
	case 76:
	this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range};
	break;
	case 77:
	this.$ = {type:"MapRecursive",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
	break;
	case 78:
	this.$ = {type:"Method",reference:$$[$0-2],arguments:[],range:this._$.range};
	break;
	case 79:
	this.$ = {type:"Method",reference:$$[$0-3],arguments:$$[$0-1],range:this._$.range};
	break;
	case 80:
	this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-2]},arguments:[],range:this._$.range};
	break;
	case 81:
	this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-3]},arguments:$$[$0-1],range:this._$.range};
	break;
	case 83: case 101: case 114: case 122:
	$$[$0-2].push($$[$0]);
	break;
	case 85:
	this.$=[$$[$0-1], ...$$[$0]];
	break;
	case 86: case 124:
	this.$ = [null,$$[$0]];
	break;
	case 87: case 126:
	this.$ = [$$[$0-1],$$[$0]];
	break;
	case 88:
	this.$=[null, $$[$0-1], ...$$[$0]];
	break;
	case 89:
	this.$=[$$[$0-2], $$[$0-1], ...$$[$0]];
	break;
	case 94: case 97:
	this.$ = {type:"Object",properties:[],range:this._$.range};
	break;
	case 95:
	this.$ = {type:"Object",properties:$$[$0-1],range:this._$.range};
	break;
	case 96:
	this.$ = {type:"Object",properties:$$[$0-2],range:this._$.range};
	break;
	case 98:
	this.$ = {type:"Block",definitions:$$[$0-2],body:{type:"Object",properties:$$[$0-1]},range:this._$.range};
	break;
	case 99:
	this.$ = {type:"Block",definitions:$$[$0-3],body:{type:"Object",properties:$$[$0-2]},range:this._$.range};
	break;
	case 102:
	this.$ = {type:"ObjectEntry",key:{type:"Current"},value:null,range:this._$.range};
	break;
	case 103:
	this.$ = {type:"ObjectEntry",key:{type:"Reference",name:$$[$0]},value:null,range:this._$.range};
	break;
	case 104:
	this.$ = {type:"ObjectEntry",key:$$[$0],value:null,range:this._$.range};
	break;
	case 105:
	this.$ = {type:"ObjectEntry",key:$$[$0-2],value:$$[$0],range:this._$.range};
	break;
	case 106: case 107: case 108:
	this.$ = {type:"ObjectEntry",key:{type:"Literal",value:$$[$0-2]},value:$$[$0],range:this._$.range};
	break;
	case 109:
	this.$ = {type:"ObjectEntry",key:{type:"Identifier",name:"$" + $$[$0-2].name},value:$$[$0],range:this._$.range};
	break;
	case 110:
	this.$ = {type:"ObjectEntry",key:$$[$0-3],value:$$[$0],range:this._$.range};
	break;
	case 111:
	this.$ = {type:"Spread",query:null,array:false,range:this._$.range};
	break;
	case 112:
	this.$ = {type:"Spread",query:$$[$0],array:false,range:this._$.range};
	break;
	case 116:
	this.$ = {type:"Spread",query:null,array:true,range:this._$.range};
	break;
	case 117:
	this.$ = {type:"Spread",query:$$[$0],array:true,range:this._$.range};
	break;
	case 118:
	this.$ = {type:"Array",elements:[],range:this._$.range};
	break;
	case 119:
	this.$ = {type:"Array",elements:$$[$0-1],range:this._$.range};
	break;
	case 120:
	this.$ = {type:"Array",elements:$$[$0-2],range:this._$.range};
	break;
	case 123:
	this.$ = {type:"Compare",query:$$[$0-1],order:$$[$0],range:this._$.range};
	break;
	case 125:
	this.$ = [null,$$[$0-1],$$[$0]];
	break;
	case 127:
	this.$ = [$$[$0-2],$$[$0-1],$$[$0]];
	break;
	case 128:
	this.$ = null;
	break;
	case 129:
	this.$ = $$[$0];
	break;
	}
	},
	table: [{3:1,4:2,5:$V0,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{1:[3]},{5:[1,44]},o($V26,[2,3],{16:6,20:9,12:14,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,7:45,8:46,9:$V1,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V26,[2,4],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V47,[2,6]),o($V48,[2,14],{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54,84:$V55}),{4:74,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,18:$V0,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:75,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o([5,10,11,18,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,56,59,74,75,77],[2,17],{66:[1,78]}),{7:79,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:80,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:81,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V57,$V58,{10:$V59,11:$V60}),o($V57,$V61,{10:$V62,11:[1,85],58:$V63}),o($V64,[2,42]),o($V64,[2,43]),o($V48,[2,121]),o($V65,[2,13]),o($V64,[2,44]),o($V64,[2,45]),o($V64,[2,47]),o($V64,[2,49]),o($V64,[2,50]),o($V64,[2,51]),o($V64,[2,52]),o($V64,[2,53]),o($V64,[2,54]),o($V64,[2,55]),{7:91,9:$V56,11:$V66,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,55:87,56:[1,88],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,80:$V67,81:89,82:92,83:17,85:90},o($V64,[2,57],{58:$V68}),o($V64,[2,58]),{6:97,7:96,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:98,14:$V2,15:$V3,57:99},{4:101,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{4:102,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:$V0,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:103,14:$V2,15:$V3,57:104},{4:105,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,84]),{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:106,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},{6:114,8:5,9:$V71,12:117,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,112],78:113,79:115,80:$V76},o($V65,[2,12]),o($V64,[2,90]),o($V77,[2,91]),{1:[2,1]},o($V26,[2,2],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V47,[2,7]),{6:125,7:124,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:126,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:127,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:128,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:129,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:130,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:131,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:132,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:133,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:134,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:135,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:136,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:137,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:138,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:139,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:140,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:141,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:142,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:143,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:144,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:146,9:$V56,11:$V66,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,55:147,56:[1,145],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17,85:90},{12:100,13:148,14:$V2,15:$V3,57:149},{4:150,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{4:151,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:$V0,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{12:100,13:152,14:$V2,15:$V3,57:153},{4:154,6:3,7:4,8:5,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:$V0,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V48,[2,123]),{18:[1,155]},o($V78,[2,16],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,$V58),o($V64,$V61,{58:$V63}),{9:$V56,12:77,13:30,14:$V2,15:$V3,16:157,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:156},o($V79,[2,20],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V80,[2,21],{31:$V36,32:$V37,33:$V38}),o($V80,[2,22],{31:$V36,32:$V37,33:$V38}),o($V47,[2,8]),{7:158,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V47,[2,10]),{7:159,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:162,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:[1,160],60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,65:161,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{56:[1,163]},o($V64,[2,118]),{56:[1,164],66:[1,165]},{11:$V66,56:[2,124],85:166},o($V81,$V82,{85:167,11:$V66,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V81,[2,113]),o($V83,[2,128],{16:6,20:9,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,7:168,9:$V56,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V81,[2,116],{16:6,20:9,42:15,43:16,83:17,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,7:169,9:$V56,14:$V2,15:$V3,17:$V4,19:$V5,22:$V6,23:$V7,24:$V8,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),{7:162,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,59:[1,170],60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,65:171,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,59:[1,172]},{7:173,8:46,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,61],{58:$V68}),o($V64,[2,62]),{58:$V63},{59:[1,174]},{56:[1,175]},o($V64,[2,65],{58:$V68}),o($V64,[2,66]),{59:[1,176]},o($V64,[2,85]),o($V64,[2,86]),{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,70:177,71:178,74:$V69,75:$V70},{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:179,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},o($V64,[2,93]),o($V77,[2,92]),o($V64,[2,94]),{66:[1,181],77:[1,180]},{8:46,9:$V71,12:117,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,182],78:183,79:115,80:$V76},o($V84,[2,100]),o($V84,$V85,{10:$V59,11:$V60}),o($V84,$V86,{10:$V62,11:[1,184]}),o($V84,[2,104],{11:[1,185]}),{11:[1,186]},{11:[1,187]},{11:[1,188]},{7:189,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V84,[2,111],{42:15,43:16,51:26,52:27,53:28,13:30,57:31,67:38,68:39,12:77,16:190,9:$V56,14:$V2,15:$V3,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,54:$V16,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,72:$V23,73:$V24,76:$V25}),o($V78,[2,18],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:191,8:46,9:$V1,12:14,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V87,[2,23],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,24],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,25],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V87,[2,26],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V79,[2,27],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o([5,10,11,18,21,30,41,56,59,66,74,75,77],[2,28],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45}),o($V80,[2,29],{31:$V36,32:$V37,33:$V38}),o($V80,[2,30],{31:$V36,32:$V37,33:$V38}),o($V48,[2,31]),o($V48,[2,32]),o($V48,[2,33]),o($V88,[2,34],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),o($V88,[2,35],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),o($V89,[2,36],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,37],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,38],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V89,[2,39],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38}),o($V88,[2,40],{23:$V28,24:$V29,31:$V36,32:$V37,33:$V38,36:$V41,37:$V42,38:$V43,39:$V44}),{11:[1,192],21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},o($V64,[2,68]),{11:$V66,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,56:[1,193],85:167},{56:[1,194]},o($V64,[2,71],{58:$V68}),o($V64,[2,72]),{59:[1,195]},{56:[1,196]},o($V64,[2,75],{58:$V68}),o($V64,[2,76]),{59:[1,197]},o($V48,[2,15]),o($V48,[2,122]),{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54,84:$V55},{10:[1,198],21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},{10:$V90,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46},o($V64,[2,80]),{59:[1,200],66:$V91},o($V92,[2,82],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,[2,56]),o($V64,[2,119]),{7:204,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,56:[1,202],57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,80:$V67,82:203,83:17},{56:[2,125]},{11:$V66,56:[2,126],85:205},o($V83,[2,129],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V81,[2,117],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V64,[2,78]),{59:[1,206],66:$V91},o($V64,[2,59]),{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,59:[1,207]},o($V64,[2,63]),o($V64,[2,64]),o($V64,[2,67]),o($V64,[2,87]),{7:108,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,69:208,70:107,71:109,72:$V23,73:$V24,74:$V69,75:$V70,76:$V25,83:17},o($V64,[2,88]),o($V64,[2,95]),{9:$V93,12:212,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,209],79:210,80:$V76},o($V64,[2,97]),{66:[1,214],77:[1,213]},{7:215,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:216,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:217,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:218,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{7:219,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46,56:[1,220]},o($V84,[2,112],{54:$V49,60:$V50,61:$V51,62:$V52,63:$V53,64:$V54}),o($V78,[2,19],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:221,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,69]),o($V64,[2,70]),o($V64,[2,73]),o($V64,[2,74]),o($V64,[2,77]),o($V47,[2,9]),o($V47,[2,11]),o($V64,[2,81]),{7:222,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,120]),o($V81,[2,114]),o($V81,$V82,{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{56:[2,127]},o($V64,[2,79]),o($V64,[2,60]),o($V64,[2,89]),o($V64,[2,96]),o($V84,[2,101]),o($V84,$V85),o($V84,$V86,{11:[1,223]}),o($V64,[2,98]),{9:$V93,12:212,13:118,14:$V2,15:$V3,47:$V72,48:$V73,50:$V74,54:$V75,77:[1,224],79:210,80:$V76},o($V84,$V94,{10:$V90,21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,105],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,106],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,107],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,108],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{11:[1,225]},o($V78,[2,41],{23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V92,[2,83],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),{7:226,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V64,[2,99]),{7:227,9:$V56,12:77,13:30,14:$V2,15:$V3,16:6,17:$V4,19:$V5,20:9,22:$V6,23:$V7,24:$V8,42:15,43:16,44:$V9,45:$V10,46:$V11,47:$V12,48:$V13,49:$V14,50:$V15,51:26,52:27,53:28,54:$V16,57:31,58:$V17,60:$V18,61:$V19,62:$V20,63:$V21,64:$V22,67:38,68:39,72:$V23,73:$V24,76:$V25,83:17},o($V84,$V94,{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46}),o($V84,[2,110],{21:$V27,23:$V28,24:$V29,25:$V30,26:$V31,27:$V32,28:$V33,29:$V34,30:$V35,31:$V36,32:$V37,33:$V38,34:$V39,35:$V40,36:$V41,37:$V42,38:$V43,39:$V44,40:$V45,41:$V46})],
	defaultActions: {44:[2,1],166:[2,125],205:[2,127]},
	parseError: function(str, hash) {
	        if (hash.recoverable) {
	            this.trace(str);
	        } else {
	            const error = new Error(str);
	            error.hash = hash;
	            throw error;
	        }
	    },
	parse: function parse(input, ...parseArgs) {
	    // use own constants for source generation reasons
	    const SHIFT = 1;
	    const REDUCE = 2;
	    const ACCEPT = 3;
	    const TERROR = 2;
	    const EOF = 1;

	    const popStack = n => {
	        stack.length -= 2 * n;
	        vstack.length -= n;
	        lstack.length -= n;
	    };
	    const lex = /** @replace token stack */ () => {
	        let token = lexer.lex() || EOF;

	        // if token isn't its numeric value, convert
	        if (typeof token !== 'number') {
	            token = this.symbols_[token] || token;
	        }

	        return token;
	    }; /** @replace */

	    const lexer = Object.create(this.lexer);
	    const ranges = lexer.options && lexer.options.ranges;
	    const sharedYY = { // shared state
	        ...this.yy,
	        parser: this,
	        lexer
	    };

	    lexer.setInput(input, sharedYY);

	    if (typeof sharedYY.parseError === 'function') {
	        this.parseError = sharedYY.parseError;
	    }

	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }

	    const table = this.table;
	    const yyval = {};
	    let yylloc = lexer.yylloc;
	    const stack = [0];
	    const vstack = [null]; // semantic value stack
	    const lstack = [yylloc]; // location stack
	    let yytext = '';
	    let yylineno = 0;
	    let yyleng = 0;
	    let recovering = 0;
	    let symbol;
	    let preErrorSymbol;
	    while (true) {
	        // retreive state number from top of stack
	        let state = stack[stack.length - 1];
	        let action;

	        // use default actions if available
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }

	            // read action for current state and first input
	            action = table[state] && table[state][symbol];
	        }

	        // handle parse error
	        if (!action || !action[0]) {
	            let errorRuleDepth;
	            let errStr = '';

	            if (!recovering) {
	                // first see if there's any chance at hitting an error recovery rule:
	                

	                // Report error
	                const expected = [];
	                for (const p in table[state]) {
	                    if (p in this.terminals_ && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }

	                errStr = lexer.showPosition
	                    ? 'Parse error on line ' + (yylineno + 1) + ':\n' +
	                        lexer.showPosition() + '\n' +
	                        'Expecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\''
	                    : 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' +
	                        (symbol === EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");

	                this.parseError(errStr, {
	                    text: lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: lexer.yylineno,
	                    loc: yylloc,
	                    
	                    expected
	                });
	            }

	            // just recovered from another error
	            if (recovering === 3) {
	                if (symbol === EOF || preErrorSymbol === EOF) {
	                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
	                }

	                // discard current lookahead and grab another
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yylloc = lexer.yylloc;
	                symbol = lex();
	            }

	            popStack(errorRuleDepth);
	            preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
	            symbol = TERROR; // insert generic error symbol as new lookahead
	            state = stack[stack.length - 1];
	            action = table[state] && table[state][TERROR];
	            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
	        }

	        // this shouldn't happen, unless resolve defaults are off
	        if (Array.isArray(action[0]) && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }

	        switch (action[0]) {
	            case SHIFT:
	                stack.push(symbol);
	                vstack.push(lexer.yytext);
	                lstack.push(lexer.yylloc);
	                stack.push(action[1]); // push state
	                symbol = null;

	                if (!preErrorSymbol) { // normal execution/no error
	                    yyleng = lexer.yyleng;
	                    yytext = lexer.yytext;
	                    yylineno = lexer.yylineno;
	                    yylloc = lexer.yylloc;
	                    if (recovering > 0) {
	                        recovering--;
	                    }
	                } else {
	                    // error just occurred, resume old lookahead f/ before error
	                    symbol = preErrorSymbol;
	                    preErrorSymbol = null;
	                }

	                break;

	            case REDUCE: {
	                const len = this.productions_[action[1]][1];

	                // perform semantic action
	                yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
	                // default location, uses first token for firsts, last for lasts
	                yyval._$ = {
	                    first_line: lstack[lstack.length - (len || 1)].first_line,
	                    last_line: lstack[lstack.length - 1].last_line,
	                    first_column: lstack[lstack.length - (len || 1)].first_column,
	                    last_column: lstack[lstack.length - 1].last_column
	                };

	                if (ranges) {
	                    yyval._$.range = [
	                        lstack[lstack.length - (len || 1)].range[0],
	                        lstack[lstack.length - 1].range[1]
	                    ];
	                }

	                const actionResult = this.performAction.call(
	                    yyval,
	                    yytext,
	                    yyleng,
	                    yylineno,
	                    sharedYY,
	                    action[1],
	                    vstack,
	                    lstack,
	                    ...parseArgs
	                );

	                if (typeof actionResult !== 'undefined') {
	                    return actionResult;
	                }

	                // pop off stack
	                if (len) {
	                    popStack(len);
	                }

	                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
	                vstack.push(yyval.$);
	                lstack.push(yyval._$);
	                // goto new state = table[STATE][NONTERMINAL]
	                stack.push(table[stack[stack.length - 2]][stack[stack.length - 1]]);
	                break;
	            }

	            case ACCEPT:
	                return true;
	        }
	    }
	}};
	/* Lexer generated by jison 0.4.18-remastered.1 */
	var lexer = (function(){
	var lexer = {
	options: {"ranges":true},
	performAction: function(yy,yy_,__lexelActionId,YY_START) {
	switch (__lexelActionId) {
	case 0:{yy.commentRanges.push(yy_.yylloc.range);
	break;}
	case 1:{
	break;}
	case 2:{this.popState(); return 32;
	}
	case 3:{this.popState(); return 36;
	}
	case 4:{
	                this.done = false;
	                this.popState();
	            
	break;}
	case 5:{
	                const token = yy_.yytext.endsWith('`') ? 'TEMPLATE' : 'TPL_START';
	                yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + (token !== 'TEMPLATE'));
	                if (token === 'TEMPLATE') {
	                    yy.pps();
	                }
	                return token;
	}
	case 6:{
	                const token = yy_.yytext.endsWith('`') ? 'TPL_END' : 'TPL_CONTINUE';
	                yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + (token !== 'TPL_END'));
	                this.popState();
	                if (token === 'TPL_END') {
	                    yy.pps();
	                }
	                return token;
	}
	case 7:{break;}
	case 8:{return 58;
	}
	case 9:{yy.pps(); return 59;
	}
	case 10:{return 54;
	}
	case 11:{yy.pps(); return 56;
	}
	case 12:{return 76;
	}
	case 13:{
	                if (this.bracketStack[this.bracketStack.length - 1] !== 'TPL_END') {
	                    yy.pps();
	                    return 77;
	                }

	                this.unput('}');
	                this.begin('template');
	            
	break;}
	case 14:{
	                yy_.yytext = this.toLiteral(yy_.yytext);
	                return 50;
	}
	case 15:{return 29;
	}
	case 16:{return 30;
	}
	case 17:{return 28;
	}
	case 18:{return 26;
	}
	case 19:{return 25;
	}
	case 20:{return 27;
	}
	case 21:{return 22;
	}
	case 22:{return 84;
	}
	case 23:{yy.pps(); yy_.yytext = Number(yy_.yytext); return 48;
	}
	case 24:{yy.pps(); yy_.yytext = parseInt(yy_.yytext, 16); return 48;
	}
	case 25:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 47;
	}
	case 26:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 47;
	}
	case 27:{yy.pps(); yy_.yytext = this.toRegExp(yy_.yytext); return 49;
	}
	case 28:{yy.pps(); yy_.yytext = this.ident(yy_.yytext); return 14;
	}
	case 29:{yy.pps(); yy_.yytext = this.ident(yy_.yytext.slice(1)); return 15;
	}
	case 30:{yy.pps(); return 44;
	}
	case 31:{yy.pps(); return 45;
	}
	case 32:{yy.pps(); return 46;
	}
	case 33:{yy.pps(); return 9;
	}
	case 34:{return 19;
	}
	case 35:{
	                this.fnOpened++;
	                return 17;
	}
	case 36:{return 34;
	}
	case 37:{return 35;
	}
	case 38:{return 40;
	}
	case 39:{return 39;
	}
	case 40:{return 37;
	}
	case 41:{return 36;
	}
	case 42:{
	                if (this.fnOpened) {
	                    this.fnOpened--;
	                    return 18;
	                }
	                return 38;
	}
	case 43:{return 64;
	}
	case 44:{return 61;
	}
	case 45:{return 62;
	}
	case 46:{return 80;
	}
	case 47:{yy.pps(); return 63;
	}
	case 48:{yy.pps(); return 60;
	}
	case 49:{return 41;
	}
	case 50:{return 66;
	}
	case 51:{return 11;
	}
	case 52:{return 10;
	}
	case 53:{return 23;
	}
	case 54:{return 24;
	}
	case 55:{return 31;
	}
	case 56:{return 32;
	}
	case 57:{return 33;
	}
	case 58:{return 21;
	}
	case 59:{return 5;
	}
	}
	},
	rules: [/^(?:\/\/.*?(?:\n|\r\n?|\u2028|\u2029|$)|\/\*(?:.|\s)*?(?:\*\/|$))/,/^\s+/,/^\//,/^<(?!=)/,/^/,(input, state) => {
	    if (input[0] !== (state === 'template' ? '}' : '`')) {
	        return null;
	    }

	    for (let i = 1; i < input.length; i++) {
	        if (input[i] === '`') {
	            return i + 1;
	        }

	        if (input[i] === '$' && input[i + 1] === '{') {
	            return i + 2;
	        }

	        if (input[i] === '\\') {
	            i++;
	        }
	    }

	    return null;
	},(input, state) => {
	    if (input[0] !== (state === 'template' ? '}' : '`')) {
	        return null;
	    }

	    for (let i = 1; i < input.length; i++) {
	        if (input[i] === '`') {
	            return i + 1;
	        }

	        if (input[i] === '$' && input[i + 1] === '{') {
	            return i + 2;
	        }

	        if (input[i] === '\\') {
	            i++;
	        }
	    }

	    return null;
	},/^/,/^\(/,/^\)/,/^\[/,/^\]/,/^\{/,/^\}/,/^(?:(true|false|null|undefined|Infinity|NaN)\b)/,/^and\b/,/^or\b/,/^has\s+no\b/,/^has\b/,/^in\b/,/^not\s+in\b/,/^not?\b/,/^(?:(asc|desc)(NA?|AN?)?\b)/,/^(?:(\d+\.|\.)?\d+([eE][-+]?\d+)?\b)/,/^0[xX][0-9a-fA-F]+/,/^(?:"(?:\\[\\"]|[^"])*")/,/^(?:'(?:\\[\\']|[^'])*')/,/^(?:\/(?:\\.|[^/])+\/i?)/,/^(?:(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^(?:\$(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^@/,/^#/,/^\$\$/,/^\$/,/^=>/,/^<(?!=)/,/^=/,/^!=/,/^~=/,/^>=/,/^<=/,/^</,/^>/,/^\.\.\(/,/^\.\(/,/^\.\[/,/^\.\.\./,/^\.\./,/^\./,/^\?/,/^,/,/^:/,/^;/,/^\-/,/^\+/,/^\*/,/^\//,/^\%/,/^(?:\|)/,/^$/],
	conditions: {"preventPrimitive":{"rules":[0,1,2,3,4,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59],"inclusive":true},"template":{"rules":[6,7],"inclusive":false},"INITIAL":{"rules":[0,1,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59],"inclusive":true}},
	EOF:1,
	setInput(input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = false;
	        this._backtrack = false;
	        this.done = false;
	        this.currentCondition = 'INITIAL';
	        this.conditionStack = ['INITIAL'];
	        this.offset = 0;
	        this.yytext = this.matched = this.match = '';
	        this.yyleng = 0;
	        this.yylineno = 0;
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };

	        {
	            this.yylloc.range = [0, 0];
	        }

	        return this;
	    },
	parseError(str, details) {
	        if (!this.yy.parser) {
	            throw new Error(str);
	        }

	        this.yy.parser.parseError(str, details);
	    },
	input() {
	        const ch = this._input[0];
	        this.offset++;
	        this.yyleng++;
	        this.yytext = this.match = this.matched = this.yytext + ch;
	        const lines = /\n|\r\n?|\u2028|\u2029/g.test(ch);

	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }

	        {
	            this.yylloc.range[1]++;
	        }

	        this._input = this._input.slice(1);
	        return ch;
	    },
	unput(chunk) {
	        const lines = chunk.split(/\n|\r\n?|\u2028|\u2029/g);
	        const oldLines = this.yytext.split(/\n|\r\n?|\u2028|\u2029/g);

	        this._input = chunk + this._input;
	        this.offset -= chunk.length;
	        this.yytext = this.matched = this.match = this.yytext.slice(0, -chunk.length);
	        this.yyleng = this.yytext.length;
	        this.done = false;

	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }

	        const prevLoc = this.yylloc;
	        this.yylloc = {
	            first_line: prevLoc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: prevLoc.first_column,
	            last_column: lines
	                ? (lines.length === oldLines.length ? prevLoc.first_column : 0) +
	                    oldLines[oldLines.length - lines.length].length - lines[0].length
	                : prevLoc.first_column - chunk.length
	        };

	        {
	            this.yylloc.range = [
	                prevLoc.range[0],
	                prevLoc.range[0] + this.yyleng
	            ];
	        }

	        return this;
	    },
	more() {
	        this._more = true;
	        return this;
	    },
	reject() {

	        // FIXME: remove method when options.backtrack_lexer is false
	        throw new Error('reject() is allowed only when options.backtrack_lexer = true');
	    },
	less(n) {
	        this.unput(this.match.slice(n));
	    },
	pastInput() {
	        const past = this.matched.substr(0, this.matched.length - this.match.length);

	        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n');
	    },
	upcomingInput() {
	        let next = this.match;

	        if (next.length < 20) {
	            next += this._input.substr(0, 20 - next.length);
	        }

	        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n');
	    },
	showPosition() {
	        const pre = this.pastInput();

	        return pre + this.upcomingInput() + `\n${'-'.repeat(pre.length)}^`;
	    },
	test_match(match, rule) {
	        let backup;

	        const ruleMatch = match[0];
	        this.yytext += ruleMatch;
	        this.match += ruleMatch;
	        this.matched += ruleMatch;
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        this.offset += this.yyleng;

	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(ruleMatch.length);

	        // update loc & range
	        const lineTerninator = /\n|\r\n?|\u2028|\u2029/g;
	        let lastColumnOffset = -1;
	        let ltMatch;
	        while (ltMatch = lineTerninator.exec(ruleMatch)) {
	            this.yylineno++;
	            lastColumnOffset = ltMatch.index + ltMatch[0].length;
	        }

	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lastColumnOffset !== -1
	                ? ruleMatch.length - lastColumnOffset
	                : this.yylloc.last_column + ruleMatch.length
	        };

	        {
	            this.yylloc.range = [this.offset - this.yyleng, this.offset];
	        }

	        // perform action
	        const token = this.performAction.call(
	            this,
	            this.yy,
	            this,
	            rule,
	            this.conditionStack[this.conditionStack.length - 1]
	        );

	        if (!token && this._backtrack) {
	            // recover context
	            Object.assign(this, backup);

	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }

	        if (this._input) {
	            this.done = false;
	        }

	        if (typeof token === 'number' && this.yy.parser) {
	            return this.yy.parser.terminals_[token];
	        }

	        return token || false;
	    },
	next() {
	        if (this.done) {
	            return this.EOF;
	        }

	        if (!this._input) {
	            this.done = true;
	        }

	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }

	        let match;
	        let matchRuleId;

	        for (const ruleId of this.conditions[this.currentCondition].rules) {
	            const rule = this.rules[ruleId];
	            let tempMatch;

	            if (typeof rule === 'function') {
	                const ret = rule(this._input, this.currentCondition);

	                switch (typeof ret) {
	                    case 'string': tempMatch = [ret]; break;
	                    case 'number': tempMatch = [this._input.slice(0, ret)]; break;
	                    default: tempMatch = ret;
	                }
	            } else {
	                tempMatch = this._input.match(rule);
	            }

	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                matchRuleId = ruleId;

	                {
	                    break;
	                }
	            }
	        }

	        if (match) {
	            // when token is false this is a lexer rule which consumes
	            // input without producing a token (e.g. whitespace)
	            return this.test_match(match, matchRuleId);
	        }

	        if (this._input === '') {
	            return this.EOF;
	        }

	        this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	            text: '',
	            token: null,
	            line: this.yylineno
	        });
	    },
	lex() {
	        let token;

	        while (!token) {
	            token = this.next();
	        }

	        return token;
	    },
	begin(condition) {
	        this.currentCondition = condition;
	        this.conditionStack.push(condition);
	    },
	pushState(condition) {
	        this.begin(condition);
	    },
	popState() {
	        this.conditionStack.pop();

	        return this.currentCondition = (this.conditionStack.length
	            ? this.conditionStack[this.conditionStack.length - 1]
	            : 'INITIAL'
	        );
	    },
	topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);

	        return n >= 0
	            ? this.conditionStack[n]
	            : 'INITIAL';
	    },
	stateStackSize() {
	        return this.conditionStack.length;
	    }
	};module.exports = exports = lexer;return lexer.lexer = lexer;
	})();
	parserPrototype.lexer = lexer;
	function Parser() {
	  this.yy = {};
	}
	Parser.prototype = parserPrototype;parserPrototype.Parser = Parser;
	const parser = (function buildParsers(strictParser) {
	    function patch(subject, patches) {
	        Object.entries(patches).forEach(([key, patch]) =>
	            subject[key] = patch(subject[key])
	        );
	    }

	    function forwardLoc(lexer, offset, str) {
	        const lines = str.split(/\r\n?|\n|\u2028|\u2029/g);
	        lexer.yylineno += lines.length - 1;
	        lexer.yylloc.first_line = lexer.yylineno + 1;
	        lexer.yylloc.first_column = lexer.length > 1 ? lines[lines.length - 1].length + 1 : lexer.yylloc.first_column + lines[0].length;
	        lexer.yylloc.range[0] += offset;
	        lexer.offset += offset;
	        lexer.match = lexer.match.slice(offset);
	    }

	    // better error details
	    const humanTokens = new Map([
	        ['EOF', ['<end of input>']],
	        ['IDENT', ['ident']],
	        ['$IDENT', ['$ident']],
	        ['FUNCTION_START', ["'<'"]],
	        ['FUNCTION_END', ["'>'"]],
	        ['FUNCTION', ["'=>'"]],
	        ['NOT', ["'not'"]],
	        ['IN', ["'in'"]],
	        ['HAS', ["'has'"]],
	        ['NOTIN', ["'not in'"]],
	        ['HASNO', ["'has no'"]],
	        ['AND', ["'and'"]],
	        ['OR', ["'or'"]],
	        ['STRING', ['string']],
	        ['TPL_START', ['template']],
	        ['TEMPLATE', ['template']],
	        ['NUMBER', ['number']],
	        ['REGEXP', ['regexp']],
	        ['LITERAL', ["'true'", "'false'", "'null'", "'undefined'"]],
	        ['ORDER', ["'asc'", "'desc'", "'ascN'", "'descN'"]]
	    ]);
	    const tokenForHumans = token => humanTokens.get(token) || `'${token}'`;
	    const parseError = function(rawMessage, details = {}, yy) {
	        if (details.recoverable) {
	            this.trace(rawMessage);
	        } else {
	            if (typeof details.inside === 'number') {
	                forwardLoc(yy.lexer, details.inside, yy.lexer.match.slice(0, details.inside));
	            }

	            const yylloc = yy.lexer.yylloc;
	            const message = [
	                rawMessage.split(/\n/)[0],
	                '',
	                yy.lexer.showPosition()
	            ];
	            const expected = !Array.isArray(details.expected) ? null : [...new Set([].concat(
	                ...details.expected.map(token => tokenForHumans(token.slice(1, -1)))
	            ))];

	            if (expected) {
	                message.push(
	                    '',
	                    'Expecting ' + expected.join(', ') + ' got ' + tokenForHumans(details.token)
	                );
	            }

	            const error = new SyntaxError(message.join('\n'));

	            error.details = {
	                rawMessage: rawMessage,
	                text: details.text,
	                token: details.token,
	                expected,
	                loc: {
	                    range: yylloc.range,
	                    start: {
	                        line: yylloc.first_line,
	                        column: yylloc.first_column,
	                        offset: yylloc.range[0]
	                    },
	                    end: {
	                        line: yylloc.last_line,
	                        column: yylloc.last_column,
	                        offset: yylloc.range[1]
	                    }
	                }
	            };

	            throw error;
	        }
	    };

	    // add new helpers to lexer
	    const lineTerminator = new Set(['\n', '\r', '\u2028', '\u2029']);
	    Object.assign(strictParser.lexer, {
	        ident: value => value.replace(/\\u[0-9a-fA-F]{4}/g, m => String.fromCharCode(parseInt(m.slice(2), 16))),

	        toLiteral: value =>
	            /* eslint-disable operator-linebreak, indent */
	            value === 'null' ? null :
	            value === 'false' ? false :
	            value === 'true' ? true :
	            value === 'Infinity' ? Infinity :
	            value === 'NaN' ? NaN :
	            undefined,
	            /* eslint-enable */

	        toStringLiteral(value, multiline = false, end = 1) {
	            let result = '';
	            for (let i = 1; i < value.length - end; i++) {
	                if (!multiline && lineTerminator.has(value[i])) {
	                    this.parseError('Invalid line terminator', { inside: i });
	                }

	                if (value[i] !== '\\') {
	                    result += value[i];
	                    continue;
	                }

	                const next = value[++i];
	                switch (next) {
	                    case '\r':
	                        // ignore line terminator
	                        i += value[i + 1] === '\n';  // \r\n
	                        break;

	                    case '\n':
	                    case '\u2028':
	                    case '\u2029':
	                        // ignore line terminator
	                        break;

	                    case 'b': result += '\b'; break;
	                    case 'n': result += '\n'; break;
	                    case 'r': result += '\r'; break;
	                    case 'f': result += '\f'; break;
	                    case 't': result += '\t'; break;
	                    case 'v': result += '\v'; break;

	                    case 'u': {
	                        const hex4 = value.slice(i + 1, i + 5);

	                        if (/^[0-9a-f]{4}$/i.test(hex4)) {
	                            result += String.fromCharCode(parseInt(hex4, 16));
	                            i += 4;
	                            break;
	                        }

	                        this.parseError('Invalid Unicode escape sequence', { inside: i - 1 });
	                        break;
	                    }

	                    case 'x': {
	                        const hex2 = value.slice(i + 1, i + 3);

	                        if (/^[0-9a-f]{2}$/i.test(hex2)) {
	                            result += String.fromCharCode(parseInt(hex2, 16));
	                            i += 2;
	                            break;
	                        }

	                        this.parseError('Invalid hexadecimal escape sequence', { inside: i - 1 });
	                        break;
	                    }

	                    default:
	                        result += next;
	                }
	            }

	            return result;
	        },

	        toRegExp: value => new RegExp(
	            value.substr(1, value.lastIndexOf('/') - 1),
	            value.substr(value.lastIndexOf('/') + 1)
	        )
	    });

	    // patch setInput method to add additional lexer fields on init
	    patch(strictParser.lexer, {
	        setInput: origSetInput => function(input, yy) {
	            const commentRanges = [];

	            yy.commentRanges = commentRanges;
	            yy.buildResult = ast => ({
	                ast,
	                commentRanges
	            });
	            yy.parseError = function(...args) {
	                // parser doesn't expose sharedState and it's unavailable in parseError
	                return parseError.call(this, ...args, yy);
	            };
	            yy.pps = () => {
	                if (this._input) {
	                    this.begin('preventPrimitive');
	                }
	            };

	            this.fnOpened = 0;
	            this.fnOpenedStack = [];
	            this.bracketStack = [];
	            this.prevToken = null;
	            this.prevYylloc = {
	                first_line: 1,
	                last_line: 1,
	                first_column: 0,
	                last_column: 0,
	                range: [0, 0]
	            };

	            return origSetInput.call(this, input, yy);
	        }
	    });

	    //
	    // tolerant parser
	    //
	    const tolerantParser = new strictParser.Parser();
	    tolerantParser.lexer = { ...strictParser.lexer };
	    tolerantParser.yy = { ...strictParser.yy };

	    // patch tolerant parser lexer
	    const keywords = [
	        'AND', 'OR', 'IN', 'NOTIN', 'HAS', 'HASNO'
	    ];
	    const words = [...keywords, 'NOT', 'ORDER'];
	    const operators = [
	        '+', '-', '*', '/', '%', '|',
	        '=', '!=', '~=', '>=', '<=', '<', '>'
	    ];
	    const prev = [
	        null, ':', ';',
	        ',', '.', '..',
	        'FUNCTION',
	        ...operators,
	        ...keywords, 'NOT'
	    ];
	    const defaultNext = new Set([
	        ',', '?', ':', ';', 'EOF',
	        ']', ')', '}',
	        ...operators,
	        ...keywords,
	        'ORDER'
	    ]);
	    const tokenPair = new Map(prev.map(token => [token, defaultNext]));
	    // special cases
	    tokenPair.set('{', new Set([',']));
	    tokenPair.set('[', new Set([',']));
	    tokenPair.set('(', new Set([',']));

	    patch(tolerantParser.lexer, {
	        lex: origLex => function patchedLex() {
	            const prevInput = this._input;
	            const nextToken = origLex.call(this);

	            if (tokenPair.has(this.prevToken) && tokenPair.get(this.prevToken).has(nextToken)) {
	                const yylloc = {
	                    first_line: this.prevYylloc.last_line,
	                    last_line: this.yylloc.first_line,
	                    first_column: this.prevYylloc.last_column,
	                    last_column: this.yylloc.first_column,
	                    range: [this.prevYylloc.range[1], this.yylloc.range[0]]
	                };
	                this.unput(this.yytext);
	                this.pushState('preventPrimitive');
	                this.done = false;
	                this.yytext = '_';
	                this.yylloc = this.prevYylloc = yylloc;

	                // position correction for a white space before a keyword
	                if (prevInput !== this._input && words.includes(nextToken)) {
	                    const prevChIndex = prevInput.length - this._input.length - 1;

	                    switch (prevInput[prevChIndex]) {
	                        case ' ':
	                        case '\t':
	                            yylloc.last_column--;
	                            yylloc.range[1]--;
	                            break;

	                        case '\n': {
	                            const lastN = prevInput.lastIndexOf('\n', prevChIndex - 1);

	                            yylloc.last_line--;
	                            yylloc.last_column = lastN === -1
	                                ? yylloc.last_column - 1
	                                : prevChIndex - lastN;
	                            yylloc.range[1]--;
	                            break;
	                        }
	                    }
	                }

	                return this.prevToken = 'IDENT';
	            }

	            this.prevYylloc = this.yylloc;

	            // position correction for a white space after a keyword
	            if (words.includes(nextToken)) {
	                switch (this._input[0]) {
	                    case ' ':
	                    case '\t':
	                        this.prevYylloc = {
	                            ...this.prevYylloc,
	                            last_column: this.prevYylloc.last_column + 1,
	                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
	                        };
	                        break;

	                    case '\n':
	                        this.prevYylloc = {
	                            ...this.prevYylloc,
	                            last_line: this.prevYylloc.last_line + 1,
	                            last_column: 0,
	                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
	                        };
	                        break;
	                }
	            }

	            return this.prevToken = nextToken;
	        }
	    });

	    // bracket balance & scope
	    const openBalance = new Map([
	        ['(', ')'],
	        ['.(', ')'],
	        ['..(', ')'],
	        ['[', ']'],
	        ['.[', ']'],
	        ['{', '}'],
	        ['TPL_START', 'TPL_END']
	    ]);
	    const closeBalance = new Set([')', ']', '}', 'TPL_END']);
	    const balanceScopeLex = origLex => function patchedLex() {
	        const token = origLex.call(this);

	        if (closeBalance.has(token)) {
	            const expected = this.bracketStack.pop();

	            if (expected !== token) {
	                this.parseError(`Expected "${expected}" got "${token}"`);
	            }

	            this.fnOpened = this.fnOpenedStack.pop() || 0;
	        }

	        if (openBalance.has(token)) {
	            this.bracketStack.push(openBalance.get(token));
	            this.fnOpenedStack.push(this.fnOpened);
	            this.fnOpened = 0;
	        }

	        return token;
	    };
	    patch(strictParser.lexer, {
	        lex: balanceScopeLex
	    });
	    patch(tolerantParser.lexer, {
	        lex: balanceScopeLex
	    });

	    return {
	        parse(source, tolerantMode) {
	            return tolerantMode
	                ? tolerantParser.parse(source)
	                : strictParser.parse(source);
	        },
	        *tokenize(source, tolerantMode, loc) {
	            const lexer = Object.create(tolerantMode ? tolerantParser.lexer : strictParser.lexer);

	            lexer.setInput(source, {
	                parser: strictParser
	            });

	            while (!lexer.done) {
	                const token = {
	                    type: lexer.lex(),
	                    value: lexer.match,
	                    offset: lexer.yylloc.range[0]
	                };

	                if (loc) {
	                    token.loc = {
	                        range: lexer.yylloc.range,
	                        start: {
	                            line: lexer.yylloc.first_line,
	                            column: lexer.yylloc.first_column
	                        },
	                        end: {
	                            line: lexer.yylloc.last_line,
	                            column: lexer.yylloc.last_column
	                        }
	                    };
	                }

	                yield token;
	            }
	        }
	    };
	})(new Parser);
	module.exports = exports = parser;
	return parser;
	})();
	});

	var Arg1 = {
	    build() {
	        return {
	            type: 'Arg1'
	        };
	    },
	    compile(node, ctx) {
	        ctx.put(ctx.scope.arg1 ? 'arguments[1]' : 'undefined');
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put('$$');
	    }
	};

	var _Array = {
	    build(elements) {
	        return {
	            type: 'Array',
	            elements
	        };
	    },
	    suggest(node, ctx) {
	        if (node.elements.length === 0) {
	            ctx.queryRoot(node.range[0] + 1, node.range[1] - 1);
	        }
	    },
	    compile(node, ctx) {
	        ctx.put('[');
	        ctx.list(node.elements, ',');
	        ctx.put(']');
	    },
	    walk(node, ctx) {
	        ctx.list(node.elements);
	    },
	    stringify(node, ctx) {
	        ctx.put('[');
	        ctx.list(node.elements, ',');
	        ctx.put(']');
	    }
	};

	const binary = {
	    'in': 'in',
	    'not in': 'in',
	    'has': '-',
	    'has no': '-',
	    'and': 'and',
	    'or': 'or',
	    '+': 'add',
	    '-': 'sub',
	    '*': 'mul',
	    '/': 'div',
	    '%': 'mod',
	    '=': 'eq',
	    '!=': 'ne',
	    '<': 'lt',
	    '<=': 'lte',
	    '>': 'gt',
	    '>=': 'gte',
	    '~=': 'match'
	};

	function valueSubset(ctx, values, extra) {
	    if (extra.type === 'Array') {
	        if (extra.elements.length === 0) {
	            ctx.range([extra.range[0] + 1, extra.range[1] - 1], 'value-subset', values, extra);
	        }

	        for (const { type, range, value } of extra.elements) {
	            if (range && (type === 'Literal' || type === 'Identifier' || (type === 'GetProperty' && value === null))) {
	                ctx.range(range, 'value-subset', values, extra);
	            }
	        }
	    }
	}

	var Binary = {
	    build(operator, left, right) {
	        return {
	            type: 'Binary',
	            operator,
	            left,
	            right
	        };
	    },
	    suggest(node, ctx) {
	        switch (node.operator) {
	            case 'in':
	                ctx.range(node.left.range, 'in-value', node.right, null);
	                valueSubset(ctx, node.left, node.right);
	                break;

	            case 'not in':
	                valueSubset(ctx, node.left, node.right);
	                break;

	            case 'has':
	                ctx.range(node.right.range, 'in-value', node.left, null);
	                valueSubset(ctx, node.right, node.left);
	                break;

	            case 'has no':
	                valueSubset(ctx, node.right, node.left);
	                break;

	            case '=':
	            case '!=':
	                ctx.range(node.right.range, 'value', node.left, null);
	                break;
	        }
	    },
	    compile(node, ctx) {
	        if (node.operator in binary === false) {
	            ctx.error('Unknown operator "' + node.operator + '"', node);
	            return;
	        }

	        if (node.operator === 'and' ||
	            node.operator === 'not in' ||
	            node.operator === 'has no') {
	            ctx.put('!');
	        }

	        switch (node.operator) {
	            case 'or':
	            case 'and': {
	                const tmpVar = ctx.allocateVar();

	                ctx.put(`f.bool(${tmpVar}=`);
	                ctx.node(node.left);
	                ctx.put(`)?${tmpVar}:`);
	                ctx.scope.captureCurrent.disabled = true;
	                ctx.node(node.right);
	                ctx.scope.captureCurrent.disabled = false;
	                break;
	            }

	            case 'has':
	            case 'has no':
	                ctx.put('f.in(');
	                ctx.node(node.right);
	                ctx.put(',');
	                ctx.node(node.left);
	                ctx.put(')');
	                break;

	            default:
	                ctx.put('f.');
	                ctx.put(binary[node.operator]);
	                ctx.put('(');
	                ctx.node(node.left);
	                ctx.put(',');
	                ctx.node(node.right);
	                ctx.put(')');
	        }
	    },
	    walk(node, ctx) {
	        ctx.node(node.left);
	        ctx.node(node.right);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.left);

	        if (/^[a-z]/i.test(node.operator)) {
	            ctx.put(' ');
	            ctx.put(node.operator);
	            ctx.put(' ');
	        } else {
	            ctx.put(node.operator);
	        }

	        ctx.node(node.right);
	    }
	};

	var Block = {
	    build(definitions, body) {
	        return {
	            type: 'Block',
	            definitions,
	            body
	        };
	    },
	    suggest(node, ctx) {
	        if (node.body === null) {
	            ctx.queryRoot(node.range[1]);
	        }
	    },
	    compile(node, ctx) {
	        if (node.definitions.length) {
	            ctx.createScope(
	                () => {
	                    ctx.put('(()=>{');
	                    ctx.list(node.definitions);
	                    ctx.put('return ');
	                    ctx.nodeOrCurrent(node.body);
	                    ctx.put('})()');
	                },
	                (scopeStart, sp) => {
	                    return scopeStart + sp + ';';
	                }
	            );
	        } else if (node.body && node.body.type === 'Object') {
	            ctx.put('(');
	            ctx.nodeOrCurrent(node.body);
	            ctx.put(')');
	        } else {
	            ctx.nodeOrCurrent(node.body);
	        }
	    },
	    walk(node, ctx) {
	        ctx.list(node.definitions);
	        ctx.nodeOrNothing(node.body);
	    },
	    stringify(node, ctx) {
	        ctx.list(node.definitions);
	        ctx.nodeOrNothing(node.body);
	    }
	};

	const comparator = {
	    '': 'cmp',
	    'N': 'cmpNatural',
	    'A': 'cmpAnalytical',
	    'NA': 'cmpNaturalAnalytical',
	    'AN': 'cmpNaturalAnalytical'
	};

	var Compare = {
	    build(query, order) {
	        return {
	            type: 'Compare',
	            query,
	            order
	        };
	    },
	    compile(node, ctx) {
	        if (node.order.startsWith('desc')) {
	            ctx.put('-');
	        }

	        ctx.createScope(
	            () => {
	                const cmpFn = comparator[node.order.slice(3 + node.order.startsWith('desc'))] || comparator[''];

	                ctx.put('f.' + cmpFn + '((_q=current=>(');
	                ctx.node(node.query);
	                ctx.put('))(a),_q(b))');
	            },
	            (scopeStart, sp) => {
	                return scopeStart + sp + ',';
	            }
	        );
	    },
	    walk(node, ctx) {
	        ctx.node(node.query);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.query);
	        ctx.put(' ');
	        ctx.put(node.order);
	    }
	};

	var Conditional = {
	    build(test, consequent, alternate) {
	        return {
	            type: 'Conditional',
	            test,
	            consequent,
	            alternate
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('f.bool(');
	        ctx.node(node.test);
	        ctx.scope.captureCurrent.disabled = true;
	        ctx.put(')?');
	        ctx.node(node.consequent);
	        ctx.put(':');
	        ctx.node(node.alternate);
	        ctx.scope.captureCurrent.disabled = false;
	    },
	    walk(node, ctx) {
	        ctx.node(node.test);
	        ctx.node(node.consequent);
	        ctx.node(node.alternate);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.test);
	        ctx.put('?');
	        ctx.node(node.consequent);
	        ctx.put(':');
	        ctx.node(node.alternate);
	    }
	};

	var Context = {
	    build() {
	        return {
	            type: 'Context'
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('context');
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put('#');
	    }
	};

	var Current = {
	    build() {
	        return {
	            type: 'Current'
	        };
	    },
	    suggest(node, ctx) {
	        if (node.range) {
	            ctx.range(node.range, 'var');
	        }
	    },
	    compile(node, ctx) {
	        ctx.put('current');
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put('$');
	    }
	};

	var Data = {
	    build() {
	        return {
	            type: 'Data'
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('data');
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put('@');
	    }
	};

	var Declarator = {
	    build(name) {
	        return {
	            type: 'Declarator',
	            name
	        };
	    },
	    compile(node, ctx) {
	        if (node.name) {
	            ctx.put('$' + node.name);
	        }
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put(node.name ? '$' + node.name : '$');
	    }
	};

	var GetProperty = {
	    build(value, property) {
	        return {
	            type: 'GetProperty',
	            value,
	            property
	        };
	    },
	    suggest(node, ctx) {
	        ctx.range(node.property.range, 'path', node.value || undefined, !node.value);

	        if (node.value === null) {
	            ctx.range(node.property.range, 'var');
	        }

	        if (node.range &&
	            node.value === null &&
	            node.property.range[0] !== node.range[0]) {
	            ctx.queryRoot(node.range[0]);
	        }
	    },
	    compile(node, ctx) {
	        ctx.put('f.map(');
	        ctx.nodeOrCurrent(node.value);
	        ctx.put(',');

	        if (node.property.type === 'Identifier') {
	            ctx.put(JSON.stringify(node.property.name));
	        } else {
	            ctx.node(node.property);
	        }

	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.node(node.property);
	    },
	    stringify(node, ctx) {
	        ctx.nodeOrNothing(node.value) && ctx.put('.');
	        ctx.node(node.property);
	    }
	};

	var Identifier = {
	    build(name) {
	        return {
	            type: 'Identifier',
	            name
	        };
	    },
	    compile(node, ctx) {
	        ctx.put(node.name);
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put(node.name);
	    }
	};

	const GetProperty$1 = GetProperty.build;
	const Identifier$1 = Identifier.build;
	const reservedVars = ['data', 'context', 'ctx', 'array', 'idx', 'index'];

	var Definition = {
	    build(declarator, value) {
	        return {
	            type: 'Definition',
	            declarator,
	            value
	        };
	    },
	    suggest(node, ctx) {
	        if (node.value === null) {
	            ctx.range(node.declarator.range, 'path');
	        }
	    },
	    compile(node, ctx) {
	        if (node.declarator.name === null) {
	            ctx.node(node.declarator);
	            ctx.nodeOrCurrent(node.value);
	            ctx.put(';');
	            return;
	        }

	        if (ctx.scope.own.includes(node.declarator.name)) {
	            ctx.error(`Identifier "$${node.declarator.name}" has already been declared`, node.declarator);
	            return;
	        }

	        if (reservedVars.includes(node.declarator.name)) {
	            ctx.error(`Identifier "$${node.declarator.name}" is reserved for future use`, node.declarator);
	            return;
	        }

	        ctx.put('const ');
	        ctx.node(node.declarator);
	        ctx.put('=');
	        ctx.node(node.value || GetProperty$1(null, Identifier$1(node.declarator.name)));
	        ctx.put(';');

	        ctx.scope.push(node.declarator.name);
	        ctx.scope.own.push(node.declarator.name);
	    },
	    walk(node, ctx) {
	        ctx.node(node.declarator);
	        ctx.nodeOrNothing(node.value);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.declarator);

	        if (node.value !== null) {
	            ctx.put(':');
	            ctx.node(node.value);
	        }

	        ctx.put(';');
	    }
	};

	var Filter = {
	    build(value, query) {
	        return {
	            type: 'Filter',
	            value,
	            query
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('f.filter(');
	        ctx.nodeOrCurrent(node.value);
	        ctx.createScope(
	            () => {
	                ctx.put(',current=>');
	                ctx.node(node.query);
	            },
	            (scopeStart, sp) => {
	                ctx.put(')');
	                return scopeStart + '(' + sp + ',';
	            }
	        );
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.node(node.query);
	    },
	    stringify(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.put('.[');
	        ctx.node(node.query);
	        ctx.put(']');
	    }
	};

	var _Function = {
	    build(args, body, legacy) {
	        return {
	            type: 'Function',
	            arguments: args,
	            body,
	            legacy: Boolean(legacy)
	        };
	    },
	    compile(node, ctx) {
	        ctx.createScope(
	            () => {
	                ctx.scope.arg1 = true;
	                ctx.put('function(current){return ');
	                ctx.node(node.body);
	                ctx.put('}');
	            },
	            (scopeStart, sp) => {
	                return scopeStart + sp + ',';
	            }
	        );
	    },
	    walk(node, ctx) {
	        ctx.node(node.body);
	    },
	    stringify(node, ctx) {
	        if (node.legacy) {
	            ctx.put('<');
	            ctx.node(node.body);
	            ctx.put('>');
	        } else {
	            ctx.put('=>');
	            ctx.node(node.body);
	        }
	    }
	};

	var Literal = {
	    build(value) {
	        return {
	            type: 'Literal',
	            value
	        };
	    },
	    compile(node, ctx) {
	        ctx.put(typeof node.value === 'string' ? JSON.stringify(node.value) : String(node.value));
	    },
	    walk() {},
	    stringify(node, ctx) {
	        ctx.put(
	            typeof node.value === 'string'
	                ? JSON.stringify(node.value)
	                : String(node.value)
	        );
	    }
	};

	var _Map = {
	    build(value, query) {
	        return {
	            type: 'Map',
	            value,
	            query
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('f.map(');
	        ctx.nodeOrCurrent(node.value);
	        ctx.createScope(
	            () => {
	                ctx.put(',current=>');
	                ctx.node(node.query);
	            },
	            (scopeStart, sp) => {
	                ctx.put(')');
	                return scopeStart + '(' + sp + ',';
	            }
	        );
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.node(node.query);
	    },
	    stringify(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.put('.(');
	        ctx.node(node.query);
	        ctx.put(')');
	    }
	};

	var MapRecursive = {
	    build(value, query) {
	        return {
	            type: 'MapRecursive',
	            value,
	            query
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('f.mapRecursive(');
	        ctx.nodeOrCurrent(node.value);
	        ctx.createScope(
	            () => {
	                ctx.put(',current=>');
	                ctx.node(node.query);
	            },
	            (scopeStart, sp) => {
	                ctx.put(')');
	                return scopeStart + '(' + sp + ',';
	            }
	        );
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.node(node.query);
	    },
	    stringify(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.put('..');

	        if (ctx.isSimpleGetPropertyQuery(node.query) || ctx.isSimpleMethodCallQuery(node.query)) {
	            ctx.node(node.query);
	        } else {
	            ctx.put('(');
	            ctx.node(node.query);
	            ctx.put(')');
	        }
	    }
	};

	var Method = {
	    build(reference, args) {
	        return {
	            type: 'Method',
	            reference,
	            arguments: args
	        };
	    },
	    suggest(node, ctx) {
	        if (node.arguments.length === 0) {
	            ctx.queryRoot(node.range[1] - 1);
	        }
	    },
	    compile(node, ctx, relatedNode) {
	        //  default mode: method(relatedNode, ...args...)
	        // tolerant mode: (typeof method === 'function' ? method(relatedNode, ...args...) : undefined)
	        if (ctx.tolerant) {
	            ctx.put('(typeof ');
	        }

	        if (node.reference.type === 'Identifier') {
	            ctx.put('m.');
	        }

	        ctx.node(node.reference);

	        if (ctx.tolerant) {
	            ctx.put('==="function"?');

	            if (node.reference.type === 'Identifier') {
	                ctx.put('m.');
	            }

	            ctx.node(node.reference);
	        }

	        ctx.put('(');
	        ctx.nodeOrCurrent(relatedNode);

	        if (node.arguments.length) {
	            ctx.put(',');
	            ctx.list(node.arguments, ',');
	        }

	        ctx.put(')');

	        if (ctx.tolerant) {
	            ctx.put(':undefined)');
	        }
	    },
	    walk(node, ctx) {
	        ctx.node(node.reference);
	        ctx.list(node.arguments);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.reference);
	        ctx.put('(');
	        ctx.list(node.arguments, ',');
	        ctx.put(')');
	    }
	};

	var MethodCall = {
	    build(value, method) {
	        return {
	            type: 'MethodCall',
	            value,
	            method
	        };
	    },
	    compile(node, ctx) {
	        ctx.node(node.method, node.value);
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);
	        ctx.node(node.method);
	    },
	    stringify(node, ctx) {
	        ctx.nodeOrNothing(node.value) && ctx.put('.');
	        ctx.node(node.method);
	    }
	};

	var _Object = {
	    build(properties) {
	        return {
	            type: 'Object',
	            properties
	        };
	    },
	    suggest(node, ctx) {
	        if (node.properties.length === 0) {
	            ctx.queryRoot(node.range[0] + 1, node.range[1] - 1);
	        }
	    },
	    compile(node, ctx) {
	        ctx.put('{');
	        ctx.list(node.properties, ',');
	        ctx.put('}');
	    },
	    walk(node, ctx) {
	        ctx.list(node.properties);
	    },
	    stringify(node, ctx) {
	        ctx.put('{');
	        ctx.list(node.properties, ',');
	        ctx.put('}');
	    }
	};

	const GetProperty$2 = GetProperty.build;
	const Identifier$2 = Identifier.build;
	const noBracketKeyType = new Set([
	    'Literal',
	    'Identifier',
	    'Reference',
	    'Current'
	]);

	var ObjectEntry = {
	    build(key, value) {
	        return {
	            type: 'ObjectEntry',
	            key,
	            value
	        };
	    },
	    suggest(node, ctx) {
	        if (node.value === null) {
	            switch (node.key.type) {
	                case 'Identifier':
	                    ctx.range(node.range, 'path');
	                    ctx.range(node.range, 'var');
	                    break;

	                case 'Current':
	                case 'Reference':
	                    ctx.range(node.range, 'var');
	                    break;
	            }
	        }
	    },
	    compile(node, ctx) {
	        let value = node.value;

	        switch (node.key.type) {
	            case 'Current':
	                return;

	            case 'Literal':
	                ctx.node(node.key);
	                break;

	            case 'Identifier':
	                ctx.node(node.key);
	                value = value || GetProperty$2(null, Identifier$2(node.key.name));
	                break;

	            case 'Reference':
	                ctx.node(node.key.name);
	                value = value || node.key;
	                break;

	            default:
	                ctx.put('[');
	                ctx.node(node.key);
	                ctx.put(']');
	        }

	        ctx.put(':');
	        ctx.node(value);
	    },
	    walk(node, ctx) {
	        ctx.node(node.key);
	        ctx.nodeOrNothing(node.value);
	    },
	    stringify(node, ctx) {
	        if (noBracketKeyType.has(node.key.type)) {
	            ctx.node(node.key);

	            if (node.value === null) {
	                return;
	            }
	        } else {
	            ctx.put('[');
	            ctx.node(node.key);
	            ctx.put(']');
	        }

	        ctx.put(':');
	        ctx.node(node.value);
	    }
	};

	var Parentheses = {
	    build(body) {
	        return {
	            type: 'Parentheses',
	            body
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('(');
	        ctx.node(node.body);
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.node(node.body);
	    },
	    stringify(node, ctx) {
	        ctx.put('(');
	        ctx.node(node.body);
	        ctx.put(')');
	    }
	};

	var Pick = {
	    build(value, getter) {
	        return {
	            type: 'Pick',
	            value,
	            getter
	        };
	    },
	    suggest(node, ctx) {
	        if (node.getter === null) {
	            const pos = node.range[1] - 1;
	            ctx.range([pos, pos], 'key', node.value, false);
	            ctx.queryRoot(pos);
	        } else {
	            ctx.range(node.getter.range, 'key', node.value, false);
	        }
	    },
	    compile(node, ctx) {
	        ctx.put('f.pick(');
	        ctx.node(node.value);

	        if (node.getter) {
	            ctx.put(',');
	            ctx.node(node.getter);
	        }

	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.node(node.value);

	        if (node.getter !== null) {
	            ctx.node(node.getter);
	        }
	    },
	    stringify(node, ctx) {
	        ctx.node(node.value);
	        ctx.put('[');

	        if (node.getter !== null) {
	            ctx.node(node.getter);
	        }

	        ctx.put(']');
	    }
	};

	var Pipeline = {
	    build(left, right) {
	        return {
	            type: 'Pipeline',
	            left,
	            right
	        };
	    },
	    compile(node, ctx) {
	        ctx.createScope(
	            () => {
	                ctx.put('(current=>(');
	                ctx.node(node.right);
	                ctx.put('))');
	            },
	            (scopeStart, sp) => {
	                return scopeStart + sp + ';';
	            }
	        );

	        ctx.put('(');
	        ctx.node(node.left);
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.node(node.left);
	        ctx.node(node.right);
	    },
	    stringify(node, ctx) {
	        ctx.node(node.left);
	        ctx.put('|');
	        ctx.node(node.right);
	    }
	};

	var Reference = {
	    build(name) {
	        return {
	            type: 'Reference',
	            name
	        };
	    },
	    suggest(node, ctx) {
	        if (node.range) {
	            ctx.range(node.range, 'var');
	        }
	    },
	    compile(node, ctx) {
	        if (!ctx.scope.includes(node.name.name) && ctx.tolerant) {
	            // FIXME: use ctx.error() here
	            ctx.put('(typeof $');
	            ctx.node(node.name);
	            ctx.put('!=="undefined"?$');
	            ctx.node(node.name);
	            ctx.put(':undefined)');
	            return;
	        }

	        ctx.put('$');
	        ctx.node(node.name);
	    },
	    walk(node, ctx) {
	        ctx.node(node.name);
	    },
	    stringify(node, ctx) {
	        ctx.put('$');
	        ctx.node(node.name);
	    }
	};

	var SliceNotation = {
	    build(value, args) {
	        return {
	            type: 'SliceNotation',
	            value,
	            arguments: args
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('f.slice(');
	        ctx.nodeOrCurrent(node.value);
	        node.arguments.slice(0, 3).forEach(item => {
	            ctx.put(',');
	            item ? ctx.node(item) : ctx.put('undefined');
	        });
	        ctx.put(')');
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.value);

	        for (const arg of node.arguments.slice(0, 3)) {
	            if (arg) {
	                ctx.node(arg);
	            }
	        }
	    },
	    stringify(node, ctx) {
	        const [a, b, c] = node.arguments;

	        ctx.nodeOrNothing(node.value);
	        ctx.put('[');

	        if (a) {
	            ctx.node(a);
	        }

	        ctx.put(':');

	        if (b) {
	            ctx.node(b);
	        }

	        if (c) {
	            ctx.put(':');
	            ctx.node(c);
	        }

	        ctx.put(']');
	    }
	};

	var SortingFunction = {
	    build(compares) {
	        return {
	            type: 'SortingFunction',
	            compares
	        };
	    },
	    compile(node, ctx) {
	        ctx.put('(a, b)=>{let _q;return ');
	        ctx.list(node.compares, '||');
	        ctx.put('||0}');
	    },
	    walk(node, ctx) {
	        ctx.list(node.compares);
	    },
	    stringify(node, ctx) {
	        ctx.list(node.compares, ',');
	    }
	};

	var Spread = {
	    build(query, array = false) {
	        return {
	            type: 'Spread',
	            query,
	            array
	        };
	    },
	    suggest(node, ctx) {
	        if (node.query === null) {
	            ctx.queryRoot(node.range[1]);
	        }
	    },
	    compile(node, ctx) {
	        if (node.array) {
	            ctx.put('...f.ensureArray(');
	            ctx.nodeOrCurrent(node.query);
	            ctx.put(')');
	            return;
	        }

	        ctx.put('...');
	        ctx.nodeOrCurrent(node.query);
	    },
	    walk(node, ctx) {
	        ctx.nodeOrNothing(node.query);
	    },
	    stringify(node, ctx) {
	        ctx.put('...');
	        ctx.nodeOrNothing(node.query);
	    }
	};

	var Template = {
	    build(values) {
	        return {
	            type: 'Template',
	            values
	        };
	    },
	    suggest(node, ctx) {
	        for (const [idx, v] of Object.entries(node.values)) {
	            if (v === null) {
	                ctx.queryRoot(node.values[idx - 1].range[1]);
	            }
	        }
	    },
	    compile(node, ctx) {
	        for (const [idx, v] of Object.entries(node.values)) {
	            if (v === null) {
	                continue;
	            }

	            if (idx !== '0') {
	                ctx.put('+');
	            }

	            if (idx % 2 === 0) {
	                ctx.put('"' + encodeString(v.value, compileEscape) + '"');
	            } else {
	                ctx.put('(');
	                ctx.node(v);
	                ctx.put(')');
	            }
	        }
	    },
	    walk(node, ctx) {
	        for (const v of node.values) {
	            if (v !== null) {
	                ctx.node(v);
	            }
	        }
	    },
	    stringify(node, ctx) {
	        const lastIdx = String(node.values.length - 1);

	        for (const [idx, v] of Object.entries(node.values)) {
	            if (idx % 2 === 0) {
	                ctx.put(idx === '0' ? '`' : '}');
	                ctx.put(encodeString(v.value, stringifyEscape));
	                ctx.put(idx === lastIdx ? '`' : '${');
	            } else if (v !== null) {
	                ctx.node(v);
	            }
	        }
	    }
	};

	const compileEscape = new Map([
	    ['\b', '\\b'],
	    ['\n', '\\n'],
	    ['\r', '\\r'],
	    ['\f', '\\f'],
	    ['\t', '\\t'],
	    ['\v', '\\v'],
	    ['\u2028', '\\u2028'],
	    ['\u2029', '\\u2029'],
	    ['\\', '\\\\'],
	    ['"', '\\"']
	]);
	const stringifyEscape = new Map([
	    ['\b', '\\b'],
	    ['\f', '\\f'],
	    ['\t', '\\t'],
	    ['\v', '\\v'],
	    ['\\', '\\\\'],
	    ['$', '\\$']
	]);
	function encodeString(s, map) {
	    let result = '';

	    for (let i = 0; i < s.length; i++) {
	        result += map.get(s[i]) || s[i];
	    }

	    return result;
	}

	var Unary = {
	    build(operator, argument) {
	        return {
	            type: 'Unary',
	            operator,
	            argument
	        };
	    },
	    compile(node, ctx) {
	        switch (node.operator) {
	            case 'no':
	            case 'not':
	                ctx.put('!f.bool(');
	                ctx.node(node.argument);
	                ctx.put(')');
	                break;

	            case '+':
	            case '-':
	                ctx.put(node.operator);
	                ctx.node(node.argument);
	                break;

	            default: {
	                ctx.error('Unknown operator "' + node.operator + '"', node);
	            }
	        }
	    },
	    walk(node, ctx) {
	        ctx.node(node.argument);
	    },
	    stringify(node, ctx) {
	        ctx.put(node.operator);

	        if (node.operator !== '-' && node.operator !== '+') {
	            ctx.put(' ');
	        }

	        ctx.node(node.argument);
	    }
	};

	const nodes = {
	    Arg1: Arg1,
	    Array: _Array,
	    Binary: Binary,
	    Block: Block,
	    Compare: Compare,
	    Conditional: Conditional,
	    Context: Context,
	    Current: Current,
	    Data: Data,
	    Declarator: Declarator,
	    Definition: Definition,
	    Filter: Filter,
	    Function: _Function,
	    GetProperty: GetProperty,
	    Identifier: Identifier,
	    Literal: Literal,
	    Map: _Map,
	    MapRecursive: MapRecursive,
	    Method: Method,
	    MethodCall: MethodCall,
	    Object: _Object,
	    ObjectEntry: ObjectEntry,
	    Parentheses: Parentheses,
	    Pick: Pick,
	    Pipeline: Pipeline,
	    Reference: Reference,
	    SliceNotation: SliceNotation,
	    SortingFunction: SortingFunction,
	    Spread: Spread,
	    Template: Template,
	    Unary: Unary
	};

	const extract = type => new Map(
	    Object.entries(nodes)
	        .map(([key, value]) => [key, value[type]])
	        .filter(([, value]) => typeof value === 'function')
	);
	const build = {};
	extract('build').forEach(
	    (value, key) => (build[key] = value)
	);

	var nodes_1 = {
	    nodes,
	    build,
	    compile: extract('compile'),
	    walk: extract('walk'),
	    stringify: extract('stringify'),
	    suggest: extract('suggest')
	};

	const nodes$1 = nodes_1.walk;

	var walk = function walk(ast, options) {
	    function walk(node) {
	        if (nodes$1.has(node.type)) {
	            enter(node);
	            nodes$1.get(node.type)(node, ctx);
	            leave(node);
	        } else {
	            throw new Error('Unknown node type `' + node.type + '`');
	        }
	    }

	    const ctx = {
	        node: walk,
	        nodeOrNothing(node) {
	            if (node !== null) {
	                walk(node);
	            }
	        },
	        list(list) {
	            list.forEach(walk);
	        }
	    };
	    let enter = () => {};
	    let leave = () => {};

	    if (typeof options === 'function') {
	        options = { enter: options };
	    }

	    if (options) {
	        if (typeof options.enter === 'function') {
	            enter = options.enter;
	        }

	        if (typeof options.leave === 'function') {
	            leave = options.leave;
	        }
	    }

	    walk(ast);
	};

	const nodes$2 = nodes_1.suggest;


	function isSuggestProhibitedChar(str, offset) {
	    return (
	        offset >= 0 &&
	        offset < str.length &&
	        /[a-zA-Z_$0-9]/.test(str[offset])
	    );
	}

	function isWhiteSpace(str, offset) {
	    const code = str.charCodeAt(offset);
	    return code === 9 || code === 10 || code === 13 || code === 32;
	}

	function onlyWsInRange(str, start, end) {
	    for (; start < end; start++) {
	        if (!isWhiteSpace(str, start)) {
	            return false;
	        }
	    }

	    return true;
	}

	function getSuggestRanges(from, to, input, commentRanges, noSuggestOnEofPos) {
	    const ranges = [];

	    for (let i = 0; i < commentRanges.length; i++) {
	        const [commentFrom, commentTo] = commentRanges[i];

	        if (commentFrom >= to) {
	            break;
	        }

	        if (commentFrom < from) {
	            continue;
	        }

	        if (commentFrom === from) {
	            ranges.push(from, from);
	        } else {
	            ranges.push(from, commentFrom);
	        }

	        from = commentTo;
	    }

	    if (from !== input.length || !noSuggestOnEofPos) {
	        ranges.push(from, to);
	    }

	    return ranges;
	}

	function processSuggestRanges(suggestRanges, source, commentRanges, noSuggestOnEofPos) {
	    const result = [];

	    for (let i = 0; i < suggestRanges.length; i++) {
	        let [start, end, type, related] = suggestRanges[i];

	        if (onlyWsInRange(source, start, end)) {
	            while (start >= 0 && isWhiteSpace(source, start - 1)) {
	                start--;
	            }

	            while (end < source.length && isWhiteSpace(source, end)) {
	                end++;
	            }

	            // when starts on keyword/number/var end
	            if (isSuggestProhibitedChar(source, start - 1)) {
	                if (start === end) {
	                    continue;
	                }
	                start++;
	            }

	            // when ends on keyword/number/var start
	            if (isSuggestProhibitedChar(source, end)) {
	                if (start === end) {
	                    continue;
	                }
	                end--;
	            }
	        }

	        const ranges = getSuggestRanges(start, end, source, commentRanges, noSuggestOnEofPos);
	        for (let j = 0; j < ranges.length; j += 2) {
	            result.push([ranges[j], ranges[j + 1], type, related]);
	        }
	    }

	    return result;
	}

	function collectNodeSuggestions(ast) {
	    let currentNode = null;
	    const suggestions = new Map();
	    const add = (node, range) => {
	        if (!suggestions.has(node)) {
	            suggestions.set(node, [range]);
	        } else {
	            suggestions.get(node).push(range);
	        }
	    };
	    const ctx = {
	        range(range, type, node = currentNode, related = true) {
	            add(node, [...range, type, related]);
	            if (related && related !== true) {
	                add(related, []);
	            }
	        },
	        queryRoot(start, end = start) {
	            add(currentNode, [start, end, 'var', true]);
	            add(currentNode, [start, end, 'path', true]);
	        }
	    };

	    walk(ast, (node) => {
	        if (nodes$2.has(node.type)) {
	            const prevNode = currentNode;
	            currentNode = node;

	            nodes$2.get(node.type)(node, ctx);

	            currentNode = prevNode;
	        }
	    });

	    return suggestions;
	}

	var suggest = function suggest(source, { ast, commentRanges }) {
	    const suggestions = collectNodeSuggestions(ast);
	    const noSuggestOnEofPos = // edge case when source ends with a comment with no newline
	        commentRanges.length &&
	        commentRanges[commentRanges.length - 1][1] === source.length &&
	        !/[\r\n]$/.test(source);

	    for (const [node, rawRanges] of suggestions) {
	        suggestions.set(node, processSuggestRanges(rawRanges, source, commentRanges, noSuggestOnEofPos));
	    }

	    return suggestions;
	};

	const nodes$3 = nodes_1.stringify;

	function isSimpleGetPropertyQuery(node) {
	    if (node.type !== 'GetProperty') {
	        return false;
	    }

	    if (node.value && node.value.type !== 'Current') {
	        return false;
	    }

	    if (node.property.type !== 'Identifier') {
	        return false;
	    }

	    return true;
	}

	function isSimpleMethodCallQuery(node) {
	    if (node.type !== 'MethodCall') {
	        return false;
	    }

	    if (node.value && node.value.type !== 'Current') {
	        return false;
	    }

	    return true;
	}

	var stringify = function stringify(ast) {
	    function walk(node) {
	        if (nodes$3.has(node.type)) {
	            nodes$3.get(node.type)(node, ctx);
	        } else {
	            throw new Error('Unknown node type `' + node.type + '`');
	        }
	    }

	    const buffer = [];
	    const ctx = {
	        isSimpleGetPropertyQuery,
	        isSimpleMethodCallQuery,
	        put(chunk) {
	            buffer.push(chunk);
	        },
	        node: walk,
	        nodeOrNothing(node) {
	            if (node !== null) {
	                walk(node);
	                return true;
	            }
	        },
	        list(list, sep) {
	            if (!sep) {
	                list.forEach(walk);
	                return;
	            }

	            list.forEach((element, idx) => {
	                if (idx > 0) {
	                    ctx.put(sep);
	                }
	                walk(element);
	            });
	        }
	    };

	    walk(ast);

	    return buffer.join('');
	};

	var error = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    const error = Object.create(SyntaxError.prototype);
	    const errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	const nodes$4 = nodes_1.compile;

	var compile = function compile(ast, tolerant = false, suggestions = null) {
	    function getNodeSpName(node) {
	        let spName;

	        if (!nodeSpName.has(node)) {
	            spNames.push(spName = 's' + spNames.length);
	            nodeSpName.set(node, spName);
	        } else {
	            spName = nodeSpName.get(node);
	        }

	        return spName;
	    }

	    function addSuggestPoint(start, end, type, spName, related) {
	        let range = [start, end, JSON.stringify(type)];

	        if (type === 'var') {
	            if (!ctx.scope.length) {
	                return;
	            }

	            range.push(JSON.stringify(ctx.scope));
	        } else {
	            if (!spName) {
	                spNames.push(spName = 's' + spNames.length);
	            }

	            range.push(spName);

	            if (related) {
	                range.push(related);
	            }
	        }


	        normalizedSuggestRanges.push(range);

	        return spName;
	    }

	    function createScope(fn, defCurrent) {
	        const prevScope = ctx.scope;
	        const scopeStart = buffer.length;

	        ctx.scope = ctx.scope.slice();
	        ctx.scope.own = [];
	        ctx.scope.firstCurrent = null;
	        ctx.scope.captureCurrent = [];
	        ctx.scope.arg1 = prevScope.arg1 || false;

	        fn();

	        if (ctx.scope.captureCurrent.length) {
	            const spName = ctx.scope.captureCurrent.reduce(
	                (spName, range) => addSuggestPoint(...range, spName),
	                undefined
	            );
	            const stat = 'stat(' + spName + ',current)';

	            if (ctx.scope.firstCurrent) {
	                buffer[ctx.scope.firstCurrent] = stat;
	            } else {
	                buffer[scopeStart] = defCurrent(buffer[scopeStart], stat);
	            }
	        }

	        ctx.scope = prevScope;
	    }

	    function walk(node, relatedNode) {
	        let spName = false;

	        if (suggestions !== null) {
	            if (suggestions.has(node)) {
	                for (const [start, end, type, related] of suggestions.get(node)) {
	                    if (type === 'var') {
	                        addSuggestPoint(start, end, type);
	                    } else if (related === true) {
	                        ctx.scope.captureCurrent.push([start, end, type]);
	                    } else {
	                        if (!spName) {
	                            spName = getNodeSpName(node);
	                            buffer.push('stat(' + spName + ',');
	                        }

	                        if (type) {
	                            addSuggestPoint(start, end, type, spName, related && getNodeSpName(related));
	                        }
	                    }
	                }
	            }

	            if (node.type === 'Current' &&
	                ctx.scope.firstCurrent === null &&
	                ctx.scope.captureCurrent.disabled !== true) {
	                ctx.scope.firstCurrent = buffer.length;
	            }
	        }

	        if (nodes$4.has(node.type)) {
	            nodes$4.get(node.type)(node, ctx, relatedNode);
	        } else {
	            throw new Error('Unknown node type `' + node.type + '`');
	        }

	        if (spName) {
	            buffer.push(')');
	        }
	    }

	    const spNames = [];
	    const nodeSpName = new WeakMap();
	    const allocatedVars = [];
	    const normalizedSuggestRanges = [];
	    const buffer = [
	        'const current=data;',
	        { toString() {
	            return allocatedVars.length > 0 ? 'let ' + allocatedVars + ';\n' : '';
	        } },
	        { toString() {
	            return spNames.length === 0
	                ? ''
	                : [
	                    'const stat=(s,v)=>(s.add(v),v);\n',
	                    'const ' + spNames.map(name => name + '=new Set()') + ';\n'
	                ].join('');
	        } },
	        'return '
	    ];

	    const ctx = {
	        tolerant,
	        scope: [],
	        createScope,
	        error: (message, node) => {
	            const error = new SyntaxError(message);

	            if (node && node.range) {
	                error.details = {
	                    loc: {
	                        range: node.range
	                    }
	                };
	            }

	            if (!tolerant) {
	                throw error;
	            }
	        },
	        allocateVar() {
	            const name = 'tmp' + allocatedVars.length;
	            allocatedVars.push(name);
	            return name;
	        },
	        put: chunk => buffer.push(chunk),
	        node: walk,
	        nodeOrNothing(node, relatedNode) {
	            if (node) {
	                walk(node, relatedNode);
	            }
	        },
	        nodeOrCurrent(node, relatedNode) {
	            walk(node || { type: 'Current' }, relatedNode);
	        },
	        list(list, sep, relatedNode) {
	            list.forEach((node, idx) => {
	                if (idx > 0) {
	                    buffer.push(sep);
	                }
	                walk(node, relatedNode);
	            });
	        }
	    };

	    createScope(
	        () => walk(ast),
	        (scopeStart, sp) => {
	            buffer.push(')');
	            return '(' + sp + ',' + scopeStart;
	        }
	    );

	    if (suggestions !== null) {
	        buffer.push('\n,[' + normalizedSuggestRanges.map(s => '[' + s + ']') + ']');
	    }

	    try {
	        return new Function('f', 'm', 'data', 'context', buffer.join(''));
	    } catch (e) {
	        const error$1 = error('SyntaxError', 'Jora query compilation error');
	        const compiledSource = buffer.join('');

	        error$1.compiledSource = compiledSource;

	        throw error$1;
	    }
	};

	const hasOwnProperty$1 = Object.hasOwnProperty;
	const toString = Object.prototype.toString;

	function addToSet(set, value) {
	    if (value !== undefined) {
	        if (Array.isArray(value)) {
	            value.forEach(item => set.add(item));
	        } else {
	            set.add(value);
	        }
	    }

	    return set;
	}

	function getPropertyValue(value, property) {
	    return value && hasOwnProperty$1.call(value, property) ? value[property] : undefined;
	}

	function isPlainObject(value) {
	    return value !== null && typeof value === 'object' && value.constructor === Object;
	}

	function isRegExp(value) {
	    return toString.call(value) === '[object RegExp]';
	}

	function isArrayLike(value) {
	    return value && hasOwnProperty$1.call(value, 'length');
	}

	var utils = {
	    addToSet,
	    getPropertyValue,
	    isPlainObject,
	    isRegExp,
	    isArrayLike
	};

	const TYPE_EOF = 0;
	const TYPE_WS = 1;
	const TYPE_DELIM = 2;
	const TYPE_NUM = 3;
	const TYPE_WORD = 4;

	const safeCharCodeAt = (source, offset) => offset < source.length ? source.charCodeAt(offset) : 0;
	const isSign = (code) => code === 0x002B || code === 0x002D;
	const isDigit = (code) => code >= 0x0030 && code <= 0x0039;
	const isWS = (code) => (
	    code === 0x0009 ||  // \t
	    code === 0x000A ||  // \n
	    code === 0x000C ||  // \f
	    code === 0x000D ||  // \r
	    code === 0x0020     // whitespace
	);
	const isDelim = (code) => (
	    (code > 0x0020 && code < 0x0100) &&  // ascii char
	    (code < 0x0041 || code > 0x005A) &&  // not A..Z
	    (code < 0x0061 || code > 0x007A) &&  // not a..z
	    (code < 0x0030 || code > 0x0039) &&  // not 0..9
	    code !== 0x002B &&                   // not +
	    code !== 0x002D                      // not -
	) || code === 0x2116;  /* № */

	//  Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (isSign(first)) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    // if (first === 0x002E) {
	    //     // If the second code point is a digit, return true. Otherwise, return false.
	    //     return isDigit(second) ? 2 : 0;
	    // }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (isDigit(safeCharCodeAt(source, offset))) {
	        offset++;
	    }

	    return offset;
	}

	function consumeNumber(source, offset, preventFloat) {
	    let code = safeCharCodeAt(source, offset);

	    // If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (isSign(code)) {
	        code = safeCharCodeAt(source, offset += 1);
	    }

	    // While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = safeCharCodeAt(source, offset);
	    }

	    // If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit(safeCharCodeAt(source, offset + 1))) {
	        if (preventFloat) {
	            return offset;
	        }

	        // Consume them
	        let expectedEnd = offset + 2;

	        // While the next input code point is a digit, consume it and append it to repr.
	        expectedEnd = findDecimalNumberEnd(source, expectedEnd);

	        // If next char is U+002E FULL STOP (.), then don't consume
	        if (safeCharCodeAt(source, expectedEnd) === 0x002E) {
	            return offset;
	        }

	        offset = expectedEnd;
	    }

	    // If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    code = safeCharCodeAt(source, offset);
	    if (code === 0x0045 /* e */ || code === 0x0065 /* E */) {
	        let sign = 0;
	        code = safeCharCodeAt(source, offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (isSign(code)) {
	            sign = 1;
	            code = safeCharCodeAt(source, offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit(code)) {
	            // While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	function getPart(source, offset, preventFloat, preventSign) {
	    if (offset >= source.length) {
	        return TYPE_EOF;
	    }

	    let a = safeCharCodeAt(source, offset);

	    // Whitespace
	    if (isWS(a)) {
	        let end = offset + 1;

	        while (isWS(safeCharCodeAt(source, end))) {
	            end++;
	        }

	        return TYPE_WS | (end - offset << 3);
	    }

	    // Delim sequence
	    // console.log(source[offset], isDelim(a), a.toString(16), preventSign)
	    if (isDelim(a) || (preventSign && isSign(a))) {
	        let end = offset + 1;
	        let b = a;

	        do {
	            a = b;
	            b = safeCharCodeAt(source, end++);
	        } while (isDelim(b) || b === a);

	        return TYPE_DELIM | (end - offset - 1 << 3);
	    }

	    // Number
	    let b = safeCharCodeAt(source, offset + 1);
	    let c = safeCharCodeAt(source, offset + 2);
	    if (isNumberStart(a, b, c)) {
	        return TYPE_NUM | (consumeNumber(source, offset, preventFloat) - offset << 3);
	    }

	    // Word
	    let end = offset;
	    do {
	        a = b;
	        b = c;
	        c = safeCharCodeAt(source, 3 + end++);
	    } while (end < source.length && !isWS(a) && !isDelim(a) && !isDigit(a));

	    return TYPE_WORD | (end - offset << 3);
	}

	function compare(a, b, analytical) {
	    let offsetA = 0;
	    let offsetB = 0;
	    let preventFloat = false;
	    let preventSign = false;
	    let postCmpResult = 0;
	    let postCmpResultType = 0;
	    let firstPart = true;

	    do {
	        const partA = getPart(a, offsetA, preventFloat, preventSign);
	        const partB = getPart(b, offsetB, preventFloat, preventSign);
	        const typeA = partA & 7;
	        const lenA = partA >> 3;
	        const typeB = partB & 7;
	        const lenB = partB >> 3;

	        if (typeA !== typeB && firstPart) {
	            if ((typeA === TYPE_WS || typeA === TYPE_DELIM) && (typeB === TYPE_NUM || typeB === TYPE_WORD)) {
	                postCmpResult = 1;
	                postCmpResultType = typeA;
	                offsetA += lenA;
	                continue;
	            }

	            if ((typeB === TYPE_WS || typeB === TYPE_DELIM) && (typeA === TYPE_NUM || typeA === TYPE_WORD)) {
	                postCmpResult = -1;
	                postCmpResultType = typeB;
	                offsetB += lenB;
	                continue;
	            }
	        }

	        firstPart = false;

	        if (typeA !== typeB) {
	            return typeA < typeB ? -1 : 1;
	        }

	        preventFloat = false;
	        preventSign = false;

	        // both parts are the same type, no matter which type to test
	        if (typeA === TYPE_EOF) {
	            return postCmpResult;
	        }

	        // find difference in substr
	        const minLength = lenA < lenB ? lenA : lenB;
	        let substrDiff = lenA - lenB;
	        let substrDiffIdx = 0;
	        for (; substrDiffIdx < minLength; substrDiffIdx++) {
	            const cA = a[offsetA + substrDiffIdx];
	            const cB = b[offsetB + substrDiffIdx];

	            if (cA !== cB) {
	                substrDiff = cA < cB ? -1 : 1;
	                break;
	            }
	        }

	        // both parts are the same type, no matter which type to test
	        if (typeA === TYPE_WS || typeA === TYPE_DELIM) {
	            if (substrDiff !== 0 && (postCmpResult === 0 || typeA > postCmpResultType)) {
	                postCmpResultType = typeA;
	                postCmpResult = substrDiff;
	            }

	            preventFloat = a[offsetA + lenA - 1] === '.';
	        } else if (typeA === TYPE_NUM) {
	            preventSign = true;

	            if (substrDiff !== 0) {
	                const numDiff = a.substr(offsetA, lenA) - b.substr(offsetB, lenB);

	                if (numDiff !== 0) {
	                    return analytical ? -numDiff : numDiff;
	                }

	                if (postCmpResult === 0 || typeA > postCmpResultType) {
	                    const afc = safeCharCodeAt(a, offsetA);
	                    const bfc = safeCharCodeAt(b, offsetB);
	                    const order = afc === 0x002D ? -1 : 1;

	                    // a/b  -  o  +
	                    //   -  0 -1 -1
	                    //   o  1  0 -1
	                    //   +  1  1  0

	                    postCmpResultType = typeA;
	                    postCmpResult = afc !== bfc && (afc === 0x002D /* - */ || bfc === 0x002B /* + */)
	                        ? -1
	                        : afc !== bfc && (afc === 0x002B /* + */ || bfc === 0x002D /* - */)
	                            ? 1
	                            : (lenA !== lenB ? lenA < lenB : substrDiff < 0) ? -order : order;

	                    if (analytical) {
	                        postCmpResult = -postCmpResult;
	                    }
	                }
	            }
	        } else { // typeA === TYPE_WORD
	            if (substrDiff !== 0) {
	                if (substrDiffIdx < minLength) {
	                    // case insensitive checking
	                    let cnA = a[offsetA + substrDiffIdx].toLowerCase();
	                    let cnB = b[offsetB + substrDiffIdx].toLowerCase();

	                    if (cnA !== cnB) {
	                        return cnA < cnB ? -1 : 1;
	                    }
	                }

	                return substrDiff;
	            }

	            preventFloat = a[offsetA + lenA - 1] === '.';
	        }

	        offsetA += lenA;
	        offsetB += lenB;
	    } while (true);
	}

	function naturalCompare(a, b) {
	    const typeA = typeof a;
	    const typeB = typeof b;
	    let ret = 0;

	    if ((typeA === 'number' || typeA === 'string') && (typeB === 'number' || typeB === 'string')) {
	        ret = compare(String(a), String(b), false);
	    }

	    return ret;
	}
	function naturalAnalyticalCompare(a, b) {
	    const typeA = typeof a;
	    const typeB = typeof b;
	    let ret = 0;

	    if ((typeA === 'number' || typeA === 'string') && (typeB === 'number' || typeB === 'string')) {
	        ret = compare(String(a), String(b), true);
	    }

	    return ret;
	}
	var naturalCompare_1 = {
	    naturalCompare,
	    naturalAnalyticalCompare
	};

	const {
	    addToSet: addToSet$1,
	    getPropertyValue: getPropertyValue$1,
	    isPlainObject: isPlainObject$1,
	    isRegExp: isRegExp$1,
	    isArrayLike: isArrayLike$1
	} = utils;
	const { naturalCompare: naturalCompare$1, naturalAnalyticalCompare: naturalAnalyticalCompare$1 } = naturalCompare_1;
	const TYPE_BOOLEAN = 1;
	const TYPE_NAN = 2;
	const TYPE_NUMBER = 3;
	const TYPE_STRING = 4;
	const TYPE_NULL = 5;
	const TYPE_OBJECT = 6;
	const TYPE_OTHER = 7;

	function cmpType(value) {
	    switch (typeof value) {
	        case 'boolean':
	            return TYPE_BOOLEAN;
	        case 'number':
	            return value !== value ? /* NaN */ TYPE_NAN : TYPE_NUMBER;
	        case 'string':
	            return TYPE_STRING;
	        case 'object':
	            return value === null ? TYPE_NULL : TYPE_OBJECT;
	        default:
	            return TYPE_OTHER;
	    }
	}

	var compileBuildin = Object.freeze({
	    ensureArray(value) {
	        return Array.isArray(value) ? value : [value];
	    },
	    bool(value) {
	        if (Array.isArray(value)) {
	            return value.length > 0;
	        }

	        if (isPlainObject$1(value)) {
	            for (const key in value) {
	                if (hasOwnProperty.call(value, key)) {
	                    return true;
	                }
	            }

	            return false;
	        }

	        return Boolean(value);
	    },
	    add(a, b) {
	        if (Array.isArray(a) || Array.isArray(b)) {
	            return [...new Set([].concat(a, b))];
	        }

	        return a + b;
	    },
	    sub(a, b) {
	        if (Array.isArray(a)) {
	            const result = new Set(a);

	            // filter b items from a
	            if (Array.isArray(b)) {
	                b.forEach(item => result.delete(item));
	            } else {
	                result.delete(b);
	            }

	            return [...result];
	        }

	        return a - b;
	    },
	    mul(a, b) {
	        return a * b;
	    },
	    div(a, b) {
	        return a / b;
	    },
	    mod(a, b) {
	        return a % b;
	    },
	    eq(a, b) {
	        return Object.is(a, b);
	    },
	    ne(a, b) {
	        return !Object.is(a, b);
	    },
	    lt(a, b) {
	        return a < b;
	    },
	    lte(a, b) {
	        return a <= b;
	    },
	    gt(a, b) {
	        return a > b;
	    },
	    gte(a, b) {
	        return a >= b;
	    },
	    in(a, b) {
	        if (isPlainObject$1(b)) {
	            return hasOwnProperty.call(b, a);
	        }

	        return b && typeof b.indexOf === 'function' ? b.indexOf(a) !== -1 : false;
	    },
	    cmp(a, b) {
	        const typeA = cmpType(a);
	        const typeB = cmpType(b);

	        return typeA !== typeB
	            ? (typeA < typeB ? -1 : 1)
	            : (a < b ? -1 : a > b ? 1 : 0);
	    },
	    cmpAnalytical(a, b) {
	        const typeA = cmpType(a);
	        const typeB = cmpType(b);

	        if (typeA !== typeB) {
	            return typeA < typeB ? -1 : 1;
	        }

	        if (typeA === TYPE_NUMBER) {
	            return b - a; // reverse order for numbers
	        }

	        return a < b ? -1 : a > b ? 1 : 0;
	    },
	    cmpNatural(a, b) {
	        const typeA = cmpType(a);
	        const typeB = cmpType(b);

	        if ((typeA === TYPE_NUMBER || typeA === TYPE_STRING) &&
	            (typeB === TYPE_NUMBER || typeB === TYPE_STRING)) {
	            return naturalCompare$1(a, b);
	        }

	        return typeA !== typeB
	            ? (typeA < typeB ? -1 : 1)
	            : (a < b ? -1 : a > b ? 1 : 0);
	    },
	    cmpNaturalAnalytical(a, b) {
	        const typeA = cmpType(a);
	        const typeB = cmpType(b);

	        if ((typeA === TYPE_NUMBER || typeA === TYPE_STRING) &&
	            (typeB === TYPE_NUMBER || typeB === TYPE_STRING)) {
	            return naturalAnalyticalCompare$1(a, b, true);
	        }

	        return typeA !== typeB
	            ? (typeA < typeB ? -1 : 1)
	            : (a < b ? -1 : a > b ? 1 : 0);
	    },
	    match(value, pattern) {
	        if (typeof pattern === 'function') {
	            return this.some(value, pattern);
	        }

	        if (isRegExp$1(pattern)) {
	            return this.some(value, pattern.test.bind(pattern));
	        }

	        if (pattern === null || pattern === undefined) {
	            return true;
	        }

	        return false;
	    },
	    pick(current, ref = () => true) {
	        if (!current) {
	            return undefined;
	        }

	        if (typeof ref === 'function') {
	            if (Array.isArray(current) || typeof current === 'string') {
	                for (let i = 0; i < current.length; i++) {
	                    if (ref(current[i], i)) {
	                        return current[i];
	                    }
	                }
	            }

	            for (const key in current) {
	                if (hasOwnProperty.call(current, key)) {
	                    if (ref(current[key], key)) {
	                        return current[key];
	                    }
	                }
	            }

	            return undefined;
	        }

	        if (Array.isArray(current) || typeof current === 'string') {
	            return isFinite(ref)
	                ? current[ref < 0 ? current.length + Number(ref) : Number(ref) || 0]
	                : undefined;
	        }

	        return hasOwnProperty.call(current, ref) ? current[ref] : undefined;
	    },
	    map(value, getter) {
	        const fn = typeof getter === 'function'
	            ? getter
	            : current => getPropertyValue$1(current, getter);

	        if (Array.isArray(value)) {
	            return [
	                ...value.reduce(
	                    (set, item) => addToSet$1(set, fn(item)),
	                    new Set()
	                )
	            ];
	        }

	        return value !== undefined ? fn(value) : value;
	    },
	    mapRecursive(value, getter) {
	        const result = new Set();

	        addToSet$1(result, this.map(value, getter));

	        result.forEach(current =>
	            addToSet$1(result, this.map(current, getter))
	        );

	        return [...result];
	    },
	    some(value, fn) {
	        return Array.isArray(value)
	            ? value.some(current => this.bool(fn(current)))
	            : this.bool(fn(value));
	    },
	    filter(value, fn) {
	        if (Array.isArray(value)) {
	            return value.filter(current => this.bool(fn(current)));
	        }

	        return this.bool(fn(value)) ? value : undefined;
	    },
	    slice(value, from = 0, to = value && value.length, step = 1) {
	        if (!isArrayLike$1(value)) {
	            return [];
	        }

	        from = parseInt(from, 10) || 0;
	        to = parseInt(to, 10) || value.length;
	        step = parseInt(step, 10) || 1;

	        if (step !== 1) {
	            const result = [];

	            from = from < 0
	                ? Math.max(0, value.length + from)
	                : Math.min(value.length, from);
	            to = to < 0
	                ? Math.max(0, value.length + to)
	                : Math.min(value.length, to);

	            for (let i = step > 0 ? from : to - 1; i >= from && i < to; i += step) {
	                result.push(value[i]);
	            }

	            return result;
	        }

	        if (typeof value === 'string') {
	            return value.slice(from, to);
	        }

	        return Array.prototype.slice.call(value, from, to);
	    }
	});

	const {
	    addToSet: addToSet$2,
	    isPlainObject: isPlainObject$2
	} = utils;

	function noop() {}

	function self(value) {
	    return value;
	}

	function matchEntry(match) {
	    return {
	        matched: match.slice(),
	        start: match.index,
	        end: match.index + match[0].length,
	        input: match.input,
	        groups: match.groups || null
	    };
	}

	var methods = Object.freeze({
	    bool: compileBuildin.bool,
	    filter: compileBuildin.filter,
	    map: compileBuildin.map,
	    pick: compileBuildin.pick,
	    keys(current) {
	        return Object.keys(current || {});
	    },
	    values(current) {
	        const values = new Set();

	        for (const key in current) {
	            if (hasOwnProperty.call(current, key)) {
	                addToSet$2(values, current[key]);
	            }
	        }

	        return [...values];
	    },
	    entries(current) {
	        const entries = [];

	        for (const key in current) {
	            if (hasOwnProperty.call(current, key)) {
	                entries.push({ key, value: current[key] });
	            }
	        }

	        return entries;
	    },
	    fromEntries(current) {
	        const result = {};

	        if (Array.isArray(current)) {
	            current.forEach(entry => {
	                if (entry) {
	                    result[entry.key] = entry.value;
	                }
	            });
	        }

	        return result;
	    },
	    size(current) {
	        if (isPlainObject$2(current)) {
	            return Object.keys(current).length;
	        }

	        return (current && current.length) || 0;
	    },
	    sort(current, fn) {
	        let sorter;

	        if (!Array.isArray(current)) {
	            return current;
	        }

	        if (typeof fn === 'function') {
	            sorter = fn.length === 2 ? fn : (a, b) => {
	                a = fn(a);
	                b = fn(b);

	                if (Array.isArray(a) && Array.isArray(b)) {
	                    if (a.length !== b.length) {
	                        return a.length < b.length ? -1 : 1;
	                    }

	                    for (let i = 0; i < a.length; i++) {
	                        if (a[i] < b[i]) {
	                            return -1;
	                        } else if (a[i] > b[i]) {
	                            return 1;
	                        }
	                    }

	                    return 0;
	                }

	                return a < b ? -1 : a > b;
	            };
	        }

	        return current.slice().sort(sorter);
	    },
	    reverse(current) {
	        if (!Array.isArray(current)) {
	            return current;
	        }

	        return current.slice().reverse();
	    },
	    slice(current, from, to) {
	        return compileBuildin.slice(current, from, to);
	    },
	    group(current, keyGetter, valueGetter) {
	        if (typeof keyGetter !== 'function') {
	            keyGetter = noop;
	        }

	        if (typeof valueGetter !== 'function') {
	            valueGetter = self;
	        }

	        if (!Array.isArray(current)) {
	            current = [current];
	        }

	        const map = new Map();
	        const result = [];

	        current.forEach(item => {
	            let keys = keyGetter(item);

	            if (!Array.isArray(keys)) {
	                keys = [keys];
	            }

	            keys.forEach(key => {
	                if (map.has(key)) {
	                    map.get(key).add(valueGetter(item));
	                } else {
	                    map.set(key, new Set([valueGetter(item)]));
	                }
	            });
	        });

	        map.forEach((value, key) =>
	            result.push({ key, value: [...value] })
	        );

	        return result;
	    },
	    split(current, pattern) {
	        return String(current).split(pattern);
	    },
	    join(current, separator) {
	        return Array.isArray(current)
	            ? current.join(separator)
	            : String(current);
	    },
	    match(current, pattern, matchAll) {
	        const input = String(current);

	        if (matchAll) {
	            const result = [];
	            let cursor = new RegExp(pattern, pattern.flags + 'g');
	            let match;

	            while (match = cursor.exec(input)) {
	                result.push(matchEntry(match));
	            }

	            return result;
	        }

	        const match = String(current).match(pattern);
	        return match && matchEntry(match);
	    },
	    reduce(current, fn, initValue = undefined) {
	        if (Array.isArray(current)) {
	            return initValue !== undefined
	                ? current.reduce((res, current) => fn(current, res), initValue)
	                : current.reduce((res, current) => fn(current, res));
	        }

	        return fn(current, initValue);
	    }
	});

	const { addToSet: addToSet$3, isPlainObject: isPlainObject$3 } = utils;
	const contextToType = {
	    'path': 'property',
	    'key': 'value',
	    'value': 'value',
	    'in-value': 'value',
	    'value-subset': 'value',
	    'var': 'variable'
	};


	function valuesToSuggestions(context, values, related) {
	    const suggestions = new Set();
	    const addValue = value => {
	        switch (typeof value) {
	            case 'string':
	                suggestions.add(JSON.stringify(value));
	                break;
	            case 'number':
	                suggestions.add(String(value));
	                break;
	        }
	    };

	    switch (context) {
	        case '':
	        case 'path':
	            values.forEach(value => {
	                if (Array.isArray(value)) {
	                    value.forEach(item => {
	                        if (isPlainObject$3(item)) {
	                            addToSet$3(suggestions, Object.keys(item));
	                        }
	                    });
	                } else if (isPlainObject$3(value)) {
	                    addToSet$3(suggestions, Object.keys(value));
	                }
	            });
	            break;

	        case 'key':
	            values.forEach(value => {
	                if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
	                    Object.keys(value).forEach(addValue);
	                }
	            });
	            break;

	        case 'value':
	            values.forEach(value => {
	                if (Array.isArray(value)) {
	                    value.forEach(addValue);
	                } else {
	                    addValue(value);
	                }
	            });
	            break;

	        case 'in-value':
	            values.forEach(value => {
	                if (Array.isArray(value)) {
	                    value.forEach(addValue);
	                } else if (isPlainObject$3(value)) {
	                    Object.keys(value).forEach(addValue);
	                } else {
	                    addValue(value);
	                }
	            });
	            break;

	        case 'var':
	            values.forEach(value => {
	                suggestions.add('$' + value);
	            });
	            break;

	        case 'value-subset':
	            values.forEach(value => {
	                if (Array.isArray(value)) {
	                    value.forEach(addValue);
	                } else {
	                    addValue(value);
	                }
	            });

	            // delete used
	            related.forEach(arr => {
	                arr.forEach(value => {
	                    if (typeof value === 'string' || typeof value === 'number') {
	                        suggestions.delete(JSON.stringify(value));
	                    }
	                });
	            });
	            break;
	    }

	    return [...suggestions];
	}

	function findSourcePosRanges(source, pos, points, includeEmpty) {
	    const result = [];

	    for (let [from, to, context, values, related = null] of points) {
	        if (pos >= from && pos <= to && (includeEmpty || values.size || values.length)) {
	            let current = source.substring(from, to);

	            if (!/\S/.test(current)) {
	                current = '';
	                from = to = pos;
	            }

	            result.push({
	                context,
	                current,
	                from,
	                to,
	                values,
	                related
	            });
	        }
	    }

	    return result;
	}

	var stat = (source, points) => ({
	    stat(pos, includeEmpty) {
	        const ranges = findSourcePosRanges(source, pos, points, includeEmpty);

	        ranges.forEach(range => {
	            range.values = [...range.values];
	        });

	        return ranges.length ? ranges : null;
	    },
	    suggestion(pos, includeEmpty) {
	        const ranges = findSourcePosRanges(source, pos, points, includeEmpty);
	        const suggestions = [];

	        ranges.forEach(range => {
	            const { context, current, from, to, values, related } = range;

	            // console.log({current, variants:[...suggestions.get(range)], suggestions })
	            suggestions.push(
	                ...valuesToSuggestions(context, values, related)
	                    .map(value => ({
	                        current,
	                        type: contextToType[context],
	                        value,
	                        from,
	                        to
	                    }))
	            );
	        });

	        return suggestions.length ? suggestions : null;
	    }
	});

	var require$$0 = getCjsExportFromNamespace(_package$1);

	const { version: version$1 } = require$$0;
	const { tokenize, parse: parse$1 } = parse;








	const cacheStrict = new Map();
	const cacheStrictStat = new Map();
	const cacheTollerant = new Map();
	const cacheTollerantStat = new Map();

	function defaultDebugHandler(sectionName, value) {
	    console.log(`[${sectionName}]`);
	    if (typeof value === 'string') {
	        console.log(value);
	    } else if (value !== undefined) {
	        console.dir(value, { depth: null });
	    }
	    console.log();
	}

	function compileFunction(source, statMode, tolerantMode, debug) {
	    debug = typeof debug === 'function' ? debug : Boolean(debug) ? defaultDebugHandler : false;

	    if (debug) {
	        debug('=========================');
	        debug('Compile query from source', source);
	    }

	    const parseResult = parse$1(source, tolerantMode);

	    if (debug) {
	        debug('AST', parseResult.ast);
	        debug('Restored source', stringify(parseResult.ast));
	    }

	    const suggestions = statMode
	        ? suggest(source, parseResult)
	        : null;

	    if (debug && suggestions) {
	        const esc = s => JSON.stringify(s).slice(1, -1);
	        const ranges = [].concat(...[...suggestions.entries()]
	            .map(([node, ranges]) => ranges.map(range => [node, ...range]))
	        );
	        let prevRange = [];
	        let prevPrefix = null;

	        debug('Suggest ranges', ranges.sort((a, b) => a[1] - b[1]).map(([node, ...range]) => {
	            const [start, end, type, extra] = range;
	            let prelude;

	            if (!type) {
	                return;
	            }

	            if (start === prevRange[0] && end === prevRange[1]) {
	                prelude = ' '.repeat(prevPrefix.length);
	            } else {
	                const pre = esc(source.slice(0, start)).length;
	                const long = esc(source.substring(start, end)).length;

	                prevRange = range;
	                prevPrefix =
	                    ' '.repeat(pre) + (!long ? '\\' : '~'.repeat(long)) +
	                    ' ' + start + ':' + end;
	                prelude = esc(source) + '\n' + prevPrefix;
	            }

	            return (
	                prelude + ' [' + type + '] on ' + node.type +
	                (extra === true ? ' (current)' : extra ? ' & ' + extra.type : '')
	            );
	        }).join('\n'));
	    }

	    const fn = compile(parseResult.ast, tolerantMode, suggestions);

	    if (debug) {
	        debug('Compiled code', fn.toString());
	    }

	    return fn;
	}

	function createQuery(source, options) {
	    options = options || {};

	    const statMode = Boolean(options.stat);
	    const tolerantMode = Boolean(options.tolerant);
	    const localMethods = options.methods ? { ...methods, ...options.methods } : methods;
	    const cache = statMode
	        ? (tolerantMode ? cacheTollerantStat : cacheStrictStat)
	        : (tolerantMode ? cacheTollerant : cacheStrict);
	    let fn;

	    source = String(source);

	    if (cache.has(source) && !options.debug) {
	        fn = cache.get(source);
	    } else {
	        fn = compileFunction(source, statMode, tolerantMode, options.debug);
	        cache.set(source, fn);
	    }

	    return statMode
	        ? (data, context) => stat(source, fn(compileBuildin, localMethods, data, context))
	        : (data, context) => fn(compileBuildin, localMethods, data, context);
	}

	function setup(customMethods) {
	    const cacheStrict = new Map();
	    const cacheStrictStat = new Map();
	    const cacheTollerant = new Map();
	    const cacheTollerantStat = new Map();
	    const localMethods = { ...methods, ...customMethods };

	    return function query(source, options) {
	        options = options || {};

	        const statMode = Boolean(options.stat);
	        const tolerantMode = Boolean(options.tolerant);
	        const cache = statMode
	            ? (tolerantMode ? cacheTollerantStat : cacheStrictStat)
	            : (tolerantMode ? cacheTollerant : cacheStrict);
	        let fn;

	        source = String(source);

	        if (cache.has(source) && !options.debug) {
	            fn = cache.get(source);
	        } else {
	            const perform = compileFunction(source, statMode, tolerantMode, options.debug);
	            fn = statMode
	                ? (data, context) => stat(source, perform(compileBuildin, localMethods, data, context))
	                : (data, context) => perform(compileBuildin, localMethods, data, context);
	            cache.set(source, fn);
	        }

	        return fn;
	    };
	}

	var src = Object.assign(createQuery, {
	    version: version$1,
	    buildin: compileBuildin,
	    methods,
	    setup,
	    syntax: {
	        tokenize,
	        parse: parse$1,
	        suggest,
	        walk,
	        stringify,
	        compile
	    }
	});

	return src;

})));
