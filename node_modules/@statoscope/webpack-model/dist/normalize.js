"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRawFile = exports.normalizedSymbol = void 0;
const md5_1 = __importDefault(require("md5"));
const entity_resolver_1 = __importDefault(require("@statoscope/helpers/dist/entity-resolver"));
const extensions_1 = __importDefault(require("@statoscope/extensions"));
const api_1 = __importDefault(require("@statoscope/stats-extension-compressed/dist/api"));
const package_json_1 = __importDefault(require("@statoscope/stats-extension-compressed/package.json"));
const api_2 = __importDefault(require("@statoscope/stats-extension-package-info/dist/api"));
const package_json_2 = __importDefault(require("@statoscope/stats-extension-package-info/package.json"));
const package_json_3 = __importDefault(require("@statoscope/stats-extension-stats-validation-result/package.json"));
const api_3 = __importDefault(require("@statoscope/stats-extension-stats-validation-result/dist/api"));
const package_json_4 = __importDefault(require("@statoscope/stats-extension-custom-reports/package.json"));
const api_4 = __importDefault(require("@statoscope/stats-extension-custom-reports/dist/api"));
const graph_1 = __importDefault(require("@statoscope/helpers/dist/graph"));
const validate_1 = __importDefault(require("./validate"));
const module_1 = require("./module");
const denormalizeCompilation_1 = __importDefault(require("./denormalizeCompilation"));
exports.normalizedSymbol = Symbol('sttoscope.normalized');
// todo: make it injectable
const extensionContainer = new extensions_1.default();
extensionContainer.register(package_json_1.default.name, package_json_1.default.version, api_1.default);
extensionContainer.register(package_json_2.default.name, package_json_2.default.version, api_2.default);
extensionContainer.register(package_json_3.default.name, package_json_3.default.version, api_3.default);
extensionContainer.register(package_json_4.default.name, package_json_4.default.version, api_4.default);
function getHash(compilation, parent) {
    if (compilation.hash) {
        return compilation.hash;
    }
    if (parent) {
        return (0, md5_1.default)(parent.hash + String(compilation.name));
    }
    return (0, md5_1.default)(compilation.name || 'unknown');
}
function normalize(rawData) {
    const files = [];
    const compilations = [];
    const fileResolvers = new Map();
    if (!Array.isArray(rawData)) {
        rawData = [rawData];
    }
    for (const rawFile of rawData) {
        const handledFile = handleRawFile(rawFile);
        files.push(handledFile.file);
        compilations.push(...handledFile.compilations);
        fileResolvers.set(rawFile.name, handledFile.resolvers);
    }
    return { files, compilations, fileResolvers };
}
exports.default = normalize;
function handleRawFile(rawStatsFileDescriptor) {
    var _a, _b, _c;
    (0, denormalizeCompilation_1.default)(rawStatsFileDescriptor.data);
    const file = {
        name: rawStatsFileDescriptor.name,
        version: rawStatsFileDescriptor.data.version || 'unknown',
        validation: (0, validate_1.default)(rawStatsFileDescriptor.data),
        compilations: [],
        __statoscope: rawStatsFileDescriptor.data.__statoscope,
    };
    const extensions = (_c = (_b = (_a = file.__statoscope) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.map((ext) => {
        const item = extensionContainer.resolve(ext.descriptor.name);
        if (!item) {
            return {
                data: ext,
                api: null,
            };
        }
        return {
            data: ext,
            api: item.apiFactory(ext),
        };
    })) !== null && _c !== void 0 ? _c : [];
    const resolveExtension = (0, entity_resolver_1.default)(extensions, (ext) => ext.data.descriptor.name);
    const resolvers = {
        resolveExtension,
    };
    const compilations = [];
    const stack = [
        {
            compilation: rawStatsFileDescriptor.data,
            parent: null,
        },
    ];
    let cursor;
    while ((cursor = stack.pop())) {
        const handled = handleCompilation(cursor.compilation, file, cursor.parent, resolvers);
        if (cursor.parent) {
            cursor.parent.children.push(handled.data);
        }
        file.compilations.push(handled.data);
        compilations.push(handled);
        for (const child of cursor.compilation.children || []) {
            stack.push({ compilation: child, parent: handled.data });
        }
    }
    return {
        file,
        compilations,
        resolvers,
    };
}
exports.handleRawFile = handleRawFile;
function buildGraph(compilation) {
    var _a;
    const moduleGraph = new graph_1.default();
    const globalHandled = new Set();
    for (const entry of compilation.entrypoints) {
        if ((_a = entry.data.dep) === null || _a === void 0 ? void 0 : _a.module) {
            handleModuleNode(moduleGraph, entry.data.dep.module);
        }
    }
    return {
        module: moduleGraph,
    };
    function handleModuleNode(graph, module) {
        var _a, _b;
        if (globalHandled.has(module)) {
            return graph.getNode(module.identifier);
        }
        globalHandled.add(module);
        const entries = module.reasons
            .filter((r) => r.resolvedEntry)
            .map((r) => r.resolvedEntry);
        const node = (_a = graph.getNode(module.identifier)) !== null && _a !== void 0 ? _a : graph.makeNode(module.identifier, { module, entries });
        const handled = new WeakSet();
        for (const innerModule of module.modules) {
            handled.add(innerModule);
            node.addChild(handleModuleNode(graph, innerModule));
        }
        for (const dep of (_b = module.deps) !== null && _b !== void 0 ? _b : []) {
            if (handled.has(dep.module)) {
                continue;
            }
            handled.add(dep.module);
            node.addChild(handleModuleNode(graph, dep.module));
        }
        return node;
    }
}
function handleCompilation(compilation, file, parent, fileResolvers) {
    const normalized = {
        time: compilation.time,
        builtAt: compilation.builtAt,
        name: compilation.name,
        hash: getHash(compilation, parent),
        entrypoints: [],
        chunks: compilation.chunks || [],
        assets: compilation.assets || [],
        modules: compilation.modules || [],
        nodeModules: [],
        children: [],
        isChild: !!(parent === null || parent === void 0 ? void 0 : parent.hash),
        parent: (parent === null || parent === void 0 ? void 0 : parent.hash) || null,
    };
    const resolveModule = makeModuleResolver(normalized);
    const resolveChunk = (0, entity_resolver_1.default)(normalized.chunks, ({ id }) => id);
    const resolveAsset = (0, entity_resolver_1.default)(normalized.assets || [], ({ name }) => name);
    const resolvePackage = (0, entity_resolver_1.default)(normalized.nodeModules, ({ name }) => name, null, false);
    normalized.entrypoints = prepareEntries(compilation, resolveChunk, resolveAsset);
    const resolveEntrypoint = (0, entity_resolver_1.default)(normalized.entrypoints, ({ name }) => name);
    const resolvers = {
        resolveModule,
        resolveChunk,
        resolveAsset,
        resolvePackage,
        resolveEntrypoint,
        resolveExtension: fileResolvers.resolveExtension,
    };
    prepareModules(compilation, resolvers);
    prepareChunks(compilation, resolvers);
    prepareAssets(compilation, resolvers);
    extractPackages(normalized, resolvers);
    const graph = buildGraph(normalized);
    resolvePackage.lock();
    return {
        data: normalized,
        resolvers,
        graph: {
            module: graph.module,
        },
        file,
    };
}
function mergeModules(from, to) {
    var _a, _b, _c, _d;
    const chunks = new Set([...((_a = to.chunks) !== null && _a !== void 0 ? _a : []), ...((_b = from.chunks) !== null && _b !== void 0 ? _b : [])]);
    to.chunks = [...chunks];
    to.reasons = [...((_c = to.reasons) !== null && _c !== void 0 ? _c : []), ...((_d = from.reasons) !== null && _d !== void 0 ? _d : [])].reduce((all, current) => {
        if (!all.find((r) => r.moduleIdentifier === current.moduleIdentifier &&
            r.type === current.type &&
            r.loc === current.loc)) {
            all.push(current);
        }
        return all;
    }, []);
}
function makeModuleResolver(compilation) {
    const modules = [...compilation.modules];
    const resolve = (0, entity_resolver_1.default)(modules, ({ identifier }) => identifier, null, false);
    for (const chunk of compilation.chunks) {
        for (const [ix, module] of Object.entries(chunk.modules || [])) {
            const resolved = resolve(module.identifier);
            if (!resolved) {
                modules.push(module);
            }
            else {
                chunk.modules[+ix] = resolved;
                mergeModules(module, resolved);
            }
        }
    }
    compilation.modules.length = 0;
    const resolveFromCompilation = (0, entity_resolver_1.default)(compilation.modules, ({ identifier }) => identifier, null, false);
    for (const module of [...modules]) {
        if (!resolveFromCompilation(module.identifier)) {
            compilation.modules.push(module);
        }
        for (const innerModule of module.modules || []) {
            if (!resolve(innerModule.identifier)) {
                modules.push(innerModule);
            }
        }
    }
    resolve.lock();
    return resolve;
}
function prepareModule(module, resolvers) {
    var _a, _b;
    // @ts-ignore
    if (module[exports.normalizedSymbol]) {
        return;
    }
    // @ts-ignore
    module[exports.normalizedSymbol] = true;
    const { resolveChunk, resolveModule } = resolvers;
    module.resolvedResource = (0, module_1.moduleResource)(module);
    if (module.issuerPath) {
        module.issuerPath.map((i) => (i.resolvedModule = resolveModule(i.identifier)));
    }
    if (module.chunks) {
        module.chunks = module.chunks
            .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
            .filter(Boolean);
    }
    else {
        module.chunks = [];
    }
    if (module.reasons) {
        module.reasons = module.reasons.filter((r) => r.moduleIdentifier !== module.identifier);
        for (const reason of module.reasons) {
            normalizeReason(reason, resolvers);
            const resolvedModule = reason.resolvedModule;
            const resolvedEntry = reason.resolvedEntry;
            if (resolvedModule) {
                (_a = resolvedModule.deps) !== null && _a !== void 0 ? _a : (resolvedModule.deps = []);
                resolvedModule.deps.push({
                    type: 'module',
                    module: module,
                    reason: reason,
                });
            }
            if (resolvedEntry) {
                resolvedEntry.data.dep = {
                    type: 'module',
                    module: (_b = reason.resolvedModule) !== null && _b !== void 0 ? _b : module,
                    reason: reason,
                };
            }
        }
    }
    else {
        module.reasons = [];
    }
    // @ts-ignore
    module.modules = module.modules || [];
}
function normalizeReason(reason, { resolveEntrypoint, resolveModule }) {
    var _a;
    reason.resolvedModule = reason.moduleIdentifier
        ? resolveModule(reason.moduleIdentifier)
        : null;
    if (/(?:.+ )?entry$/.test((_a = reason.type) !== null && _a !== void 0 ? _a : '')) {
        if (reason.loc) {
            let resolvedName = reason.loc;
            let resolved = resolveEntrypoint(resolvedName);
            if (!resolved) {
                // handle foo[0] for webpack 4 single entry
                resolvedName = reason.loc.slice(0, -3);
                resolved = resolveEntrypoint(resolvedName);
            }
            if (resolved) {
                reason.resolvedEntryName = resolvedName;
                reason.resolvedEntry = resolved;
            }
        }
    }
}
function prepareModules(compilation, resolvers) {
    for (const [i, module] of Object.entries(compilation.modules || [])) {
        const resolved = resolvers.resolveModule(module.identifier);
        if (resolved) {
            compilation.modules[+i] = resolved;
        }
        prepareModule(module, resolvers);
        if (module.modules) {
            for (const [i, innerModule] of Object.entries(module.modules)) {
                const resolved = resolvers.resolveModule(innerModule.identifier);
                if (resolved) {
                    module.modules[+i] = resolved;
                }
                prepareModule(innerModule, resolvers);
            }
        }
        else {
            module.modules = [];
        }
    }
}
function prepareChunk(chunk, resolvers) {
    const { resolveModule, resolveAsset, resolveChunk } = resolvers;
    // @ts-ignore
    if (chunk[exports.normalizedSymbol]) {
        return;
    }
    // @ts-ignore
    chunk[exports.normalizedSymbol] = true;
    if (chunk.modules) {
        chunk.modules = chunk.modules
            .map((m) => resolveModule(m.identifier))
            .filter(Boolean);
        for (const [i, module] of Object.entries(chunk.modules)) {
            const resolved = resolvers.resolveModule(module.identifier);
            if (resolved) {
                chunk.modules[+i] = resolved;
                mergeModules(module, resolved);
            }
            prepareModule(module, resolvers);
            if (module.modules) {
                for (const [i, innerModule] of Object.entries(module.modules)) {
                    const resolved = resolvers.resolveModule(innerModule.identifier);
                    if (resolved) {
                        module.modules[+i] = resolved;
                    }
                    prepareModule(innerModule, resolvers);
                }
            }
            else {
                module.modules = [];
            }
        }
    }
    else {
        chunk.modules = [];
    }
    if (chunk.files) {
        chunk.files = chunk.files
            .map((f) => resolveAsset(typeof f === 'string' ? f : f.name))
            .filter(Boolean);
    }
    else {
        chunk.files = [];
    }
    if (chunk.children) {
        chunk.children = chunk.children
            .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
            .filter(Boolean);
        for (const children of chunk.children) {
            prepareChunk(children, resolvers);
        }
    }
    else {
        chunk.children = [];
    }
    if (chunk.siblings) {
        chunk.siblings = chunk.siblings
            .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
            .filter(Boolean);
    }
    else {
        chunk.siblings = [];
    }
    if (chunk.parents) {
        chunk.parents = chunk.parents
            .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
            .filter(Boolean);
    }
    else {
        chunk.parents = [];
    }
    if (chunk.origins) {
        chunk.origins
            .map((o) => (o.resolvedModule = o.moduleIdentifier
            ? resolveModule(o.moduleIdentifier)
            : null))
            .filter(Boolean);
    }
    else {
        chunk.origins = [];
    }
}
function prepareChunks(compilation, resolvers) {
    for (const chunk of compilation.chunks || []) {
        prepareChunk(chunk, resolvers);
    }
}
function prepareAssets(compilation, { resolveChunk }) {
    for (const asset of compilation.assets || []) {
        if (asset.chunks) {
            asset.chunks = asset.chunks
                .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
                .filter(Boolean);
        }
        else {
            asset.chunks = [];
        }
        asset.files = asset.files || [];
    }
}
function prepareEntries(compilation, resolveChunk, resolveAsset) {
    const entrypoints = [];
    for (const name in compilation.entrypoints) {
        const entry = compilation.entrypoints[name];
        if (entry.chunks) {
            entry.chunks = entry.chunks
                .map((c) => resolveChunk(typeof c === 'string' || typeof c === 'number' ? c : c.id))
                .filter(Boolean);
        }
        if (entry.assets) {
            entry.assets = entry.assets
                .map((a) => resolveAsset(typeof a === 'string' ? a : a.name))
                .filter(Boolean);
        }
        entrypoints.push({ name, data: entry });
    }
    return entrypoints;
}
function extractPackages(compilation, { resolvePackage, resolveExtension }) {
    const buildReasonKey = (type, moduleIdentifier, loc) => {
        return [type, moduleIdentifier, loc].join(';');
    };
    const extractModulePackages = (module) => {
        var _a, _b, _c;
        const resource = (0, module_1.moduleResource)(module);
        if (!resource) {
            return;
        }
        const modulePackage = (0, module_1.nodeModule)(resource);
        if (modulePackage) {
            let resolvedPackage = resolvePackage(modulePackage.name);
            if (!resolvedPackage) {
                resolvedPackage = { name: modulePackage.name, instances: [] };
                compilation.nodeModules.push(resolvedPackage);
            }
            let instance = resolvedPackage.instances.find(({ path }) => path === modulePackage.path);
            if (!instance) {
                const packageInfoExt = resolveExtension('@statoscope/stats-extension-package-info');
                const api = packageInfoExt === null || packageInfoExt === void 0 ? void 0 : packageInfoExt.api;
                const extInstance = (_a = api === null || api === void 0 ? void 0 : api.getInstance(compilation.hash, resolvedPackage.name, modulePackage.path)) !== null && _a !== void 0 ? _a : null;
                instance = {
                    path: modulePackage.path,
                    isRoot: modulePackage.isRoot,
                    reasons: [],
                    modules: [module],
                    version: extInstance === null || extInstance === void 0 ? void 0 : extInstance.info.version,
                };
                resolvedPackage.instances.push(instance);
            }
            else {
                if (!instance.modules.includes(module)) {
                    instance.modules.push(module);
                }
            }
            const instanceReasonsKeys = new Set(instance.reasons.map((reason) => {
                var _a, _b;
                return buildReasonKey(reason.type, (_a = reason.data.moduleIdentifier) !== null && _a !== void 0 ? _a : 'unknown', (_b = reason.data.loc) !== null && _b !== void 0 ? _b : 'unknown');
            }));
            for (const reason of module.reasons) {
                const reasonPackage = (0, module_1.nodeModule)((0, module_1.moduleReasonResource)(reason));
                if (reasonPackage && reasonPackage.path === instance.path) {
                    continue;
                }
                const reasonType = 'module';
                const reasonKey = buildReasonKey(reasonType, (_b = reason.moduleIdentifier) !== null && _b !== void 0 ? _b : 'unknown', (_c = reason.loc) !== null && _c !== void 0 ? _c : 'unknown');
                if (!instanceReasonsKeys.has(reasonKey)) {
                    instance.reasons.push({ type: reasonType, data: reason });
                    instanceReasonsKeys.add(reasonKey);
                }
            }
        }
    };
    function handleModule(module) {
        var _a;
        extractModulePackages(module);
        if (module.modules) {
            for (const innerModule of module.modules) {
                handleModule(innerModule);
            }
        }
        else {
            (_a = module.modules) !== null && _a !== void 0 ? _a : (module.modules = []);
        }
    }
    for (const module of compilation.modules) {
        handleModule(module);
    }
    for (const chunk of compilation.chunks) {
        for (const module of chunk.modules) {
            handleModule(module);
        }
    }
}
//# sourceMappingURL=normalize.js.map