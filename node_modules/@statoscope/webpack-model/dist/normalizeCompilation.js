"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function handleModule(module, modulesData) {
    var _a, _b, _c, _d;
    let resolvedId = modulesData.idToIxMap.get(module.identifier);
    if (!resolvedId) {
        resolvedId = modulesData.lastId++;
        modulesData.idToIxMap.set(module.identifier, resolvedId);
        modulesData.ixToModuleMap.set(resolvedId, module);
    }
    else {
        const resolvedModule = modulesData.ixToModuleMap.get(resolvedId);
        resolvedModule.chunks = [
            ...new Set([...((_a = resolvedModule.chunks) !== null && _a !== void 0 ? _a : []), ...((_b = module.chunks) !== null && _b !== void 0 ? _b : [])]),
        ];
        resolvedModule.reasons = [
            ...((_c = resolvedModule.reasons) !== null && _c !== void 0 ? _c : []),
            ...((_d = module.reasons) !== null && _d !== void 0 ? _d : []),
        ].reduce((all, current) => {
            if (!all.find((r) => r.moduleIdentifier === current.moduleIdentifier &&
                r.type === current.type &&
                r.loc === current.loc)) {
                all.push(current);
            }
            return all;
        }, []);
    }
    return resolvedId;
}
function handleChunk(chunk, modulesData) {
    for (const [id, module] of (chunk.modules || []).entries()) {
        // @ts-ignore
        chunk.modules[id] = handleModule(module, modulesData);
    }
}
function handleCompilation(compilation, compilationMap) {
    const modulesData = {
        ixToModuleMap: new Map(),
        idToIxMap: new Map(),
        lastId: 1,
    };
    compilationMap.set((compilation.hash || compilation.name), {
        modules: modulesData,
    });
    for (const [id, module] of (compilation.modules || []).entries()) {
        // @ts-ignore
        compilation.modules[id] = handleModule(module, modulesData);
    }
    for (const chunk of compilation.chunks || []) {
        handleChunk(chunk, modulesData);
    }
}
function normalizeCompilation(json) {
    const compilationMap = new Map();
    const compilations = [json];
    let cursor;
    while ((cursor = compilations.pop())) {
        handleCompilation(cursor, compilationMap);
        for (const child of cursor.children || []) {
            compilations.push(child);
        }
    }
    const normalizationData = {
        links: { modules: ['chunks'] },
        data: {
            compilations: [...compilationMap.entries()].map(([id, compilation]) => {
                return {
                    id,
                    data: {
                        modules: [...compilation.modules.ixToModuleMap.entries()],
                    },
                };
            }),
        },
    };
    // @ts-ignore
    json.__statoscope = json.__statoscope || {};
    // @ts-ignore
    json.__statoscope.normalization = normalizationData;
    return json;
}
exports.default = normalizeCompilation;
//# sourceMappingURL=normalizeCompilation.js.map